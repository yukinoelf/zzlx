// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

#ifndef PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
#define PROTOBUF_IM_2eBuddy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Buddy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBuddy_2eproto();
void protobuf_AssignDesc_IM_2eBuddy_2eproto();
void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

class IMRecentContactSessionReq;
class IMRecentContactSessionRsp;
class IMUserStatNotify;
class IMUsersInfoReq;
class IMUsersInfoRsp;
class IMRemoveSessionReq;
class IMRemoveSessionRsp;
class IMAllUserReq;
class IMAllUserRsp;
class IMUsersStatReq;
class IMUsersStatRsp;
class IMChangeAvatarReq;
class IMChangeAvatarRsp;
class IMPCLoginStatusNotify;
class IMRemoveSessionNotify;
class IMDepartmentReq;
class IMDepartmentRsp;
class IMAvatarChangedNotify;
class IMChangeSignInfoReq;
class IMChangeSignInfoRsp;
class IMSignInfoChangedNotify;
class TravelToolInfo;
class BasicInfo;
class TransportConfig;
class TravelDetail;
class TransportTool;
class DayScenic;
class DayHotel;
class PlayDetail;
class PlayConfig;
class ScenicInfo;
class HotelInfo;
class MyTravel;
class CreateMyTravelReq;
class CreateMyTravelRsp;
class DeleteMyTravelReq;
class DeleteMyTravelRsp;
class UpdateMyTravelReq;
class UpdateMyTravelRsp;
class QueryMyTravelReq;
class QueryMyTravelRsp;
class GetTransportToolReq;
class GetTransportToolRsp;
class GetScenicHotelReq;
class GetScenicHotelRsp;
class DayRoute;
class Route;
class CollectionRoute;
class NewQueryRadomRouteReq;
class NewQueryRadomRouteRsp;
class NewUpdateRadomRouteReq;
class NewUpdateRadomRouteRsp;
class NewCreateMyTravelReq;
class NewCreateMyTravelRsp;
class NewCreateCollectRouteReq;
class NewCreateCollectRouteRsp;
class NewDelCollectRouteReq;
class NewDelCollectRouteRsp;
class NewQueryCollectRouteReq;
class NewQueryCollectRouteRsp;
class Info_Modify_Req;
class Info_Modify_Rsp;

enum TransportToolType {
  TRAIN = 1,
  AIRPLANE = 2,
  BUS = 4,
  WALK = 8,
  TAXI = 16
};
bool TransportToolType_IsValid(int value);
const TransportToolType TransportToolType_MIN = TRAIN;
const TransportToolType TransportToolType_MAX = TAXI;
const int TransportToolType_ARRAYSIZE = TransportToolType_MAX + 1;

enum PositionType {
  CENTRAL = 1,
  SCENIC = 2,
  OTHER = 3
};
bool PositionType_IsValid(int value);
const PositionType PositionType_MIN = CENTRAL;
const PositionType PositionType_MAX = OTHER;
const int PositionType_ARRAYSIZE = PositionType_MAX + 1;

enum QualityType {
  QUALITY_LOW = 1,
  QUALITY_MID = 2,
  QUALITY_HIGH = 3
};
bool QualityType_IsValid(int value);
const QualityType QualityType_MIN = QUALITY_LOW;
const QualityType QualityType_MAX = QUALITY_HIGH;
const int QualityType_ARRAYSIZE = QualityType_MAX + 1;

enum ModifyType {
  NICK = 1,
  AVATAR = 2,
  SEX = 3,
  ENCOUNTER = 4,
  HOMELAND = 5,
  SIGN = 6
};
bool ModifyType_IsValid(int value);
const ModifyType ModifyType_MIN = NICK;
const ModifyType ModifyType_MAX = SIGN;
const int ModifyType_ARRAYSIZE = ModifyType_MAX + 1;

// ===================================================================

class IMRecentContactSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionReq();
  virtual ~IMRecentContactSessionReq();

  IMRecentContactSessionReq(const IMRecentContactSessionReq& from);

  inline IMRecentContactSessionReq& operator=(const IMRecentContactSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionReq* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionReq& from);
  void MergeFrom(const IMRecentContactSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRecentContactSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionRsp();
  virtual ~IMRecentContactSessionRsp();

  IMRecentContactSessionRsp(const IMRecentContactSessionRsp& from);

  inline IMRecentContactSessionRsp& operator=(const IMRecentContactSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionRsp& from);
  void MergeFrom(const IMRecentContactSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  inline int contact_session_list_size() const;
  inline void clear_contact_session_list();
  static const int kContactSessionListFieldNumber = 2;
  inline const ::IM::BaseDefine::ContactSessionInfo& contact_session_list(int index) const;
  inline ::IM::BaseDefine::ContactSessionInfo* mutable_contact_session_list(int index);
  inline ::IM::BaseDefine::ContactSessionInfo* add_contact_session_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
      contact_session_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
      mutable_contact_session_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo > contact_session_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserStatNotify : public ::google::protobuf::MessageLite {
 public:
  IMUserStatNotify();
  virtual ~IMUserStatNotify();

  IMUserStatNotify(const IMUserStatNotify& from);

  inline IMUserStatNotify& operator=(const IMUserStatNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserStatNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserStatNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserStatNotify* other);

  // implements Message ----------------------------------------------

  IMUserStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserStatNotify& from);
  void MergeFrom(const IMUserStatNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.UserStat user_stat = 1;
  inline bool has_user_stat() const;
  inline void clear_user_stat();
  static const int kUserStatFieldNumber = 1;
  inline const ::IM::BaseDefine::UserStat& user_stat() const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat();
  inline ::IM::BaseDefine::UserStat* release_user_stat();
  inline void set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserStatNotify)
 private:
  inline void set_has_user_stat();
  inline void clear_has_user_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::BaseDefine::UserStat* user_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoReq();
  virtual ~IMUsersInfoReq();

  IMUsersInfoReq(const IMUsersInfoReq& from);

  inline IMUsersInfoReq& operator=(const IMUsersInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoReq* other);

  // implements Message ----------------------------------------------

  IMUsersInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoReq& from);
  void MergeFrom(const IMUsersInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoRsp();
  virtual ~IMUsersInfoRsp();

  IMUsersInfoRsp(const IMUsersInfoRsp& from);

  inline IMUsersInfoRsp& operator=(const IMUsersInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoRsp* other);

  // implements Message ----------------------------------------------

  IMUsersInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoRsp& from);
  void MergeFrom(const IMUsersInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserInfo& user_info_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_info_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionReq();
  virtual ~IMRemoveSessionReq();

  IMRemoveSessionReq(const IMRemoveSessionReq& from);

  inline IMRemoveSessionReq& operator=(const IMRemoveSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionReq* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionReq& from);
  void MergeFrom(const IMRemoveSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionRsp();
  virtual ~IMRemoveSessionRsp();

  IMRemoveSessionRsp(const IMRemoveSessionRsp& from);

  inline IMRemoveSessionRsp& operator=(const IMRemoveSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionRsp& from);
  void MergeFrom(const IMRemoveSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 3;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 3;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserReq : public ::google::protobuf::MessageLite {
 public:
  IMAllUserReq();
  virtual ~IMAllUserReq();

  IMAllUserReq(const IMAllUserReq& from);

  inline IMAllUserReq& operator=(const IMAllUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserReq* other);

  // implements Message ----------------------------------------------

  IMAllUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserReq& from);
  void MergeFrom(const IMAllUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMAllUserRsp();
  virtual ~IMAllUserRsp();

  IMAllUserRsp(const IMAllUserRsp& from);

  inline IMAllUserRsp& operator=(const IMAllUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserRsp* other);

  // implements Message ----------------------------------------------

  IMAllUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserRsp& from);
  void MergeFrom(const IMAllUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 3;
  inline const ::IM::BaseDefine::UserInfo& user_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatReq();
  virtual ~IMUsersStatReq();

  IMUsersStatReq(const IMUsersStatReq& from);

  inline IMUsersStatReq& operator=(const IMUsersStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatReq* other);

  // implements Message ----------------------------------------------

  IMUsersStatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatReq& from);
  void MergeFrom(const IMUsersStatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatRsp();
  virtual ~IMUsersStatRsp();

  IMUsersStatRsp(const IMUsersStatRsp& from);

  inline IMUsersStatRsp& operator=(const IMUsersStatRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatRsp* other);

  // implements Message ----------------------------------------------

  IMUsersStatRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatRsp& from);
  void MergeFrom(const IMUsersStatRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  inline int user_stat_list_size() const;
  inline void clear_user_stat_list();
  static const int kUserStatListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserStat& user_stat_list(int index) const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat_list(int index);
  inline ::IM::BaseDefine::UserStat* add_user_stat_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
      user_stat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
      mutable_user_stat_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat > user_stat_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarReq();
  virtual ~IMChangeAvatarReq();

  IMChangeAvatarReq(const IMChangeAvatarReq& from);

  inline IMChangeAvatarReq& operator=(const IMChangeAvatarReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarReq* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarReq& from);
  void MergeFrom(const IMChangeAvatarReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarRsp();
  virtual ~IMChangeAvatarRsp();

  IMChangeAvatarRsp(const IMChangeAvatarRsp& from);

  inline IMChangeAvatarRsp& operator=(const IMChangeAvatarRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarRsp* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarRsp& from);
  void MergeFrom(const IMChangeAvatarRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMPCLoginStatusNotify : public ::google::protobuf::MessageLite {
 public:
  IMPCLoginStatusNotify();
  virtual ~IMPCLoginStatusNotify();

  IMPCLoginStatusNotify(const IMPCLoginStatusNotify& from);

  inline IMPCLoginStatusNotify& operator=(const IMPCLoginStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMPCLoginStatusNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMPCLoginStatusNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMPCLoginStatusNotify* other);

  // implements Message ----------------------------------------------

  IMPCLoginStatusNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMPCLoginStatusNotify& from);
  void MergeFrom(const IMPCLoginStatusNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserStatType login_stat = 2;
  inline bool has_login_stat() const;
  inline void clear_login_stat();
  static const int kLoginStatFieldNumber = 2;
  inline ::IM::BaseDefine::UserStatType login_stat() const;
  inline void set_login_stat(::IM::BaseDefine::UserStatType value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMPCLoginStatusNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_login_stat();
  inline void clear_has_login_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int login_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMPCLoginStatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionNotify : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionNotify();
  virtual ~IMRemoveSessionNotify();

  IMRemoveSessionNotify(const IMRemoveSessionNotify& from);

  inline IMRemoveSessionNotify& operator=(const IMRemoveSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionNotify* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionNotify& from);
  void MergeFrom(const IMRemoveSessionNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentReq : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentReq();
  virtual ~IMDepartmentReq();

  IMDepartmentReq(const IMDepartmentReq& from);

  inline IMDepartmentReq& operator=(const IMDepartmentReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentReq* other);

  // implements Message ----------------------------------------------

  IMDepartmentReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentReq& from);
  void MergeFrom(const IMDepartmentReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentReq* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentRsp : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentRsp();
  virtual ~IMDepartmentRsp();

  IMDepartmentRsp(const IMDepartmentRsp& from);

  inline IMDepartmentRsp& operator=(const IMDepartmentRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentRsp* other);

  // implements Message ----------------------------------------------

  IMDepartmentRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentRsp& from);
  void MergeFrom(const IMDepartmentRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  inline int dept_list_size() const;
  inline void clear_dept_list();
  static const int kDeptListFieldNumber = 3;
  inline const ::IM::BaseDefine::DepartInfo& dept_list(int index) const;
  inline ::IM::BaseDefine::DepartInfo* mutable_dept_list(int index);
  inline ::IM::BaseDefine::DepartInfo* add_dept_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
      dept_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
      mutable_dept_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo > dept_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAvatarChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMAvatarChangedNotify();
  virtual ~IMAvatarChangedNotify();

  IMAvatarChangedNotify(const IMAvatarChangedNotify& from);

  inline IMAvatarChangedNotify& operator=(const IMAvatarChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAvatarChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAvatarChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAvatarChangedNotify* other);

  // implements Message ----------------------------------------------

  IMAvatarChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAvatarChangedNotify& from);
  void MergeFrom(const IMAvatarChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAvatarChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAvatarChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoReq();
  virtual ~IMChangeSignInfoReq();

  IMChangeSignInfoReq(const IMChangeSignInfoReq& from);

  inline IMChangeSignInfoReq& operator=(const IMChangeSignInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoReq* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoReq& from);
  void MergeFrom(const IMChangeSignInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoRsp();
  virtual ~IMChangeSignInfoRsp();

  IMChangeSignInfoRsp(const IMChangeSignInfoRsp& from);

  inline IMChangeSignInfoRsp& operator=(const IMChangeSignInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoRsp* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoRsp& from);
  void MergeFrom(const IMChangeSignInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional string sign_info = 3;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 3;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMSignInfoChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMSignInfoChangedNotify();
  virtual ~IMSignInfoChangedNotify();

  IMSignInfoChangedNotify(const IMSignInfoChangedNotify& from);

  inline IMSignInfoChangedNotify& operator=(const IMSignInfoChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSignInfoChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSignInfoChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSignInfoChangedNotify* other);

  // implements Message ----------------------------------------------

  IMSignInfoChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSignInfoChangedNotify& from);
  void MergeFrom(const IMSignInfoChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMSignInfoChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMSignInfoChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class TravelToolInfo : public ::google::protobuf::MessageLite {
 public:
  TravelToolInfo();
  virtual ~TravelToolInfo();

  TravelToolInfo(const TravelToolInfo& from);

  inline TravelToolInfo& operator=(const TravelToolInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TravelToolInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TravelToolInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TravelToolInfo* other);

  // implements Message ----------------------------------------------

  TravelToolInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TravelToolInfo& from);
  void MergeFrom(const TravelToolInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 transport_tool_type = 2;
  inline bool has_transport_tool_type() const;
  inline void clear_transport_tool_type();
  static const int kTransportToolTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 transport_tool_type() const;
  inline void set_transport_tool_type(::google::protobuf::uint32 value);

  // required string no = 3;
  inline bool has_no() const;
  inline void clear_no();
  static const int kNoFieldNumber = 3;
  inline const ::std::string& no() const;
  inline void set_no(const ::std::string& value);
  inline void set_no(const char* value);
  inline void set_no(const char* value, size_t size);
  inline ::std::string* mutable_no();
  inline ::std::string* release_no();
  inline void set_allocated_no(::std::string* no);

  // required string place_from_code = 4;
  inline bool has_place_from_code() const;
  inline void clear_place_from_code();
  static const int kPlaceFromCodeFieldNumber = 4;
  inline const ::std::string& place_from_code() const;
  inline void set_place_from_code(const ::std::string& value);
  inline void set_place_from_code(const char* value);
  inline void set_place_from_code(const char* value, size_t size);
  inline ::std::string* mutable_place_from_code();
  inline ::std::string* release_place_from_code();
  inline void set_allocated_place_from_code(::std::string* place_from_code);

  // required string place_from = 5;
  inline bool has_place_from() const;
  inline void clear_place_from();
  static const int kPlaceFromFieldNumber = 5;
  inline const ::std::string& place_from() const;
  inline void set_place_from(const ::std::string& value);
  inline void set_place_from(const char* value);
  inline void set_place_from(const char* value, size_t size);
  inline ::std::string* mutable_place_from();
  inline ::std::string* release_place_from();
  inline void set_allocated_place_from(::std::string* place_from);

  // required string place_to_code = 6;
  inline bool has_place_to_code() const;
  inline void clear_place_to_code();
  static const int kPlaceToCodeFieldNumber = 6;
  inline const ::std::string& place_to_code() const;
  inline void set_place_to_code(const ::std::string& value);
  inline void set_place_to_code(const char* value);
  inline void set_place_to_code(const char* value, size_t size);
  inline ::std::string* mutable_place_to_code();
  inline ::std::string* release_place_to_code();
  inline void set_allocated_place_to_code(::std::string* place_to_code);

  // required string place_to = 7;
  inline bool has_place_to() const;
  inline void clear_place_to();
  static const int kPlaceToFieldNumber = 7;
  inline const ::std::string& place_to() const;
  inline void set_place_to(const ::std::string& value);
  inline void set_place_to(const char* value);
  inline void set_place_to(const char* value, size_t size);
  inline ::std::string* mutable_place_to();
  inline ::std::string* release_place_to();
  inline void set_allocated_place_to(::std::string* place_to);

  // required string time_from = 8;
  inline bool has_time_from() const;
  inline void clear_time_from();
  static const int kTimeFromFieldNumber = 8;
  inline const ::std::string& time_from() const;
  inline void set_time_from(const ::std::string& value);
  inline void set_time_from(const char* value);
  inline void set_time_from(const char* value, size_t size);
  inline ::std::string* mutable_time_from();
  inline ::std::string* release_time_from();
  inline void set_allocated_time_from(::std::string* time_from);

  // required string time_to = 9;
  inline bool has_time_to() const;
  inline void clear_time_to();
  static const int kTimeToFieldNumber = 9;
  inline const ::std::string& time_to() const;
  inline void set_time_to(const ::std::string& value);
  inline void set_time_to(const char* value);
  inline void set_time_to(const char* value, size_t size);
  inline ::std::string* mutable_time_to();
  inline ::std::string* release_time_to();
  inline void set_allocated_time_to(::std::string* time_to);

  // required string class = 10;
  inline bool has_class_() const;
  inline void clear_class_();
  static const int kClassFieldNumber = 10;
  inline const ::std::string& class_() const;
  inline void set_class_(const ::std::string& value);
  inline void set_class_(const char* value);
  inline void set_class_(const char* value, size_t size);
  inline ::std::string* mutable_class_();
  inline ::std::string* release_class_();
  inline void set_allocated_class_(::std::string* class_);

  // required uint32 price = 11;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 11;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TravelToolInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_transport_tool_type();
  inline void clear_has_transport_tool_type();
  inline void set_has_no();
  inline void clear_has_no();
  inline void set_has_place_from_code();
  inline void clear_has_place_from_code();
  inline void set_has_place_from();
  inline void clear_has_place_from();
  inline void set_has_place_to_code();
  inline void clear_has_place_to_code();
  inline void set_has_place_to();
  inline void clear_has_place_to();
  inline void set_has_time_from();
  inline void clear_has_time_from();
  inline void set_has_time_to();
  inline void clear_has_time_to();
  inline void set_has_class_();
  inline void clear_has_class_();
  inline void set_has_price();
  inline void clear_has_price();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 transport_tool_type_;
  ::std::string* no_;
  ::std::string* place_from_code_;
  ::std::string* place_from_;
  ::std::string* place_to_code_;
  ::std::string* place_to_;
  ::std::string* time_from_;
  ::std::string* time_to_;
  ::std::string* class__;
  ::google::protobuf::uint32 price_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TravelToolInfo* default_instance_;
};
// -------------------------------------------------------------------

class BasicInfo : public ::google::protobuf::MessageLite {
 public:
  BasicInfo();
  virtual ~BasicInfo();

  BasicInfo(const BasicInfo& from);

  inline BasicInfo& operator=(const BasicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BasicInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BasicInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BasicInfo* other);

  // implements Message ----------------------------------------------

  BasicInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BasicInfo& from);
  void MergeFrom(const BasicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string date_from = 1;
  inline bool has_date_from() const;
  inline void clear_date_from();
  static const int kDateFromFieldNumber = 1;
  inline const ::std::string& date_from() const;
  inline void set_date_from(const ::std::string& value);
  inline void set_date_from(const char* value);
  inline void set_date_from(const char* value, size_t size);
  inline ::std::string* mutable_date_from();
  inline ::std::string* release_date_from();
  inline void set_allocated_date_from(::std::string* date_from);

  // required string date_to = 2;
  inline bool has_date_to() const;
  inline void clear_date_to();
  static const int kDateToFieldNumber = 2;
  inline const ::std::string& date_to() const;
  inline void set_date_to(const ::std::string& value);
  inline void set_date_to(const char* value);
  inline void set_date_to(const char* value, size_t size);
  inline ::std::string* mutable_date_to();
  inline ::std::string* release_date_to();
  inline void set_allocated_date_to(::std::string* date_to);

  // required string place_to_code = 3;
  inline bool has_place_to_code() const;
  inline void clear_place_to_code();
  static const int kPlaceToCodeFieldNumber = 3;
  inline const ::std::string& place_to_code() const;
  inline void set_place_to_code(const ::std::string& value);
  inline void set_place_to_code(const char* value);
  inline void set_place_to_code(const char* value, size_t size);
  inline ::std::string* mutable_place_to_code();
  inline ::std::string* release_place_to_code();
  inline void set_allocated_place_to_code(::std::string* place_to_code);

  // required uint32 person_num = 4;
  inline bool has_person_num() const;
  inline void clear_person_num();
  static const int kPersonNumFieldNumber = 4;
  inline ::google::protobuf::uint32 person_num() const;
  inline void set_person_num(::google::protobuf::uint32 value);

  // required string place_from_code = 5;
  inline bool has_place_from_code() const;
  inline void clear_place_from_code();
  static const int kPlaceFromCodeFieldNumber = 5;
  inline const ::std::string& place_from_code() const;
  inline void set_place_from_code(const ::std::string& value);
  inline void set_place_from_code(const char* value);
  inline void set_place_from_code(const char* value, size_t size);
  inline ::std::string* mutable_place_from_code();
  inline ::std::string* release_place_from_code();
  inline void set_allocated_place_from_code(::std::string* place_from_code);

  // required string place_back_code = 6;
  inline bool has_place_back_code() const;
  inline void clear_place_back_code();
  static const int kPlaceBackCodeFieldNumber = 6;
  inline const ::std::string& place_back_code() const;
  inline void set_place_back_code(const ::std::string& value);
  inline void set_place_back_code(const char* value);
  inline void set_place_back_code(const char* value, size_t size);
  inline ::std::string* mutable_place_back_code();
  inline ::std::string* release_place_back_code();
  inline void set_allocated_place_back_code(::std::string* place_back_code);

  // @@protoc_insertion_point(class_scope:IM.Buddy.BasicInfo)
 private:
  inline void set_has_date_from();
  inline void clear_has_date_from();
  inline void set_has_date_to();
  inline void clear_has_date_to();
  inline void set_has_place_to_code();
  inline void clear_has_place_to_code();
  inline void set_has_person_num();
  inline void clear_has_person_num();
  inline void set_has_place_from_code();
  inline void clear_has_place_from_code();
  inline void set_has_place_back_code();
  inline void clear_has_place_back_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* date_from_;
  ::std::string* date_to_;
  ::std::string* place_to_code_;
  ::std::string* place_from_code_;
  ::std::string* place_back_code_;
  ::google::protobuf::uint32 person_num_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static BasicInfo* default_instance_;
};
// -------------------------------------------------------------------

class TransportConfig : public ::google::protobuf::MessageLite {
 public:
  TransportConfig();
  virtual ~TransportConfig();

  TransportConfig(const TransportConfig& from);

  inline TransportConfig& operator=(const TransportConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TransportConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransportConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransportConfig* other);

  // implements Message ----------------------------------------------

  TransportConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransportConfig& from);
  void MergeFrom(const TransportConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tool_type = 1;
  inline bool has_tool_type() const;
  inline void clear_tool_type();
  static const int kToolTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tool_type() const;
  inline void set_tool_type(::google::protobuf::uint32 value);

  // required string time_from = 2;
  inline bool has_time_from() const;
  inline void clear_time_from();
  static const int kTimeFromFieldNumber = 2;
  inline const ::std::string& time_from() const;
  inline void set_time_from(const ::std::string& value);
  inline void set_time_from(const char* value);
  inline void set_time_from(const char* value, size_t size);
  inline ::std::string* mutable_time_from();
  inline ::std::string* release_time_from();
  inline void set_allocated_time_from(::std::string* time_from);

  // required string time_to = 3;
  inline bool has_time_to() const;
  inline void clear_time_to();
  static const int kTimeToFieldNumber = 3;
  inline const ::std::string& time_to() const;
  inline void set_time_to(const ::std::string& value);
  inline void set_time_to(const char* value);
  inline void set_time_to(const char* value, size_t size);
  inline ::std::string* mutable_time_to();
  inline ::std::string* release_time_to();
  inline void set_allocated_time_to(::std::string* time_to);

  // required .IM.Buddy.QualityType quality = 4;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 4;
  inline ::IM::Buddy::QualityType quality() const;
  inline void set_quality(::IM::Buddy::QualityType value);

  // required uint32 transit = 5;
  inline bool has_transit() const;
  inline void clear_transit();
  static const int kTransitFieldNumber = 5;
  inline ::google::protobuf::uint32 transit() const;
  inline void set_transit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TransportConfig)
 private:
  inline void set_has_tool_type();
  inline void clear_has_tool_type();
  inline void set_has_time_from();
  inline void clear_has_time_from();
  inline void set_has_time_to();
  inline void clear_has_time_to();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_transit();
  inline void clear_has_transit();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_from_;
  ::google::protobuf::uint32 tool_type_;
  int quality_;
  ::std::string* time_to_;
  ::google::protobuf::uint32 transit_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TransportConfig* default_instance_;
};
// -------------------------------------------------------------------

class TravelDetail : public ::google::protobuf::MessageLite {
 public:
  TravelDetail();
  virtual ~TravelDetail();

  TravelDetail(const TravelDetail& from);

  inline TravelDetail& operator=(const TravelDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TravelDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TravelDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TravelDetail* other);

  // implements Message ----------------------------------------------

  TravelDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TravelDetail& from);
  void MergeFrom(const TravelDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Buddy.TransportTool transport_tool = 1;
  inline bool has_transport_tool() const;
  inline void clear_transport_tool();
  static const int kTransportToolFieldNumber = 1;
  inline const ::IM::Buddy::TransportTool& transport_tool() const;
  inline ::IM::Buddy::TransportTool* mutable_transport_tool();
  inline ::IM::Buddy::TransportTool* release_transport_tool();
  inline void set_allocated_transport_tool(::IM::Buddy::TransportTool* transport_tool);

  // required .IM.Buddy.PlayDetail play_detail = 2;
  inline bool has_play_detail() const;
  inline void clear_play_detail();
  static const int kPlayDetailFieldNumber = 2;
  inline const ::IM::Buddy::PlayDetail& play_detail() const;
  inline ::IM::Buddy::PlayDetail* mutable_play_detail();
  inline ::IM::Buddy::PlayDetail* release_play_detail();
  inline void set_allocated_play_detail(::IM::Buddy::PlayDetail* play_detail);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TravelDetail)
 private:
  inline void set_has_transport_tool();
  inline void clear_has_transport_tool();
  inline void set_has_play_detail();
  inline void clear_has_play_detail();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::TransportTool* transport_tool_;
  ::IM::Buddy::PlayDetail* play_detail_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TravelDetail* default_instance_;
};
// -------------------------------------------------------------------

class TransportTool : public ::google::protobuf::MessageLite {
 public:
  TransportTool();
  virtual ~TransportTool();

  TransportTool(const TransportTool& from);

  inline TransportTool& operator=(const TransportTool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TransportTool& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransportTool* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransportTool* other);

  // implements Message ----------------------------------------------

  TransportTool* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransportTool& from);
  void MergeFrom(const TransportTool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Buddy.TravelToolInfo from_info = 1;
  inline bool has_from_info() const;
  inline void clear_from_info();
  static const int kFromInfoFieldNumber = 1;
  inline const ::IM::Buddy::TravelToolInfo& from_info() const;
  inline ::IM::Buddy::TravelToolInfo* mutable_from_info();
  inline ::IM::Buddy::TravelToolInfo* release_from_info();
  inline void set_allocated_from_info(::IM::Buddy::TravelToolInfo* from_info);

  // required .IM.Buddy.TravelToolInfo back_info = 2;
  inline bool has_back_info() const;
  inline void clear_back_info();
  static const int kBackInfoFieldNumber = 2;
  inline const ::IM::Buddy::TravelToolInfo& back_info() const;
  inline ::IM::Buddy::TravelToolInfo* mutable_back_info();
  inline ::IM::Buddy::TravelToolInfo* release_back_info();
  inline void set_allocated_back_info(::IM::Buddy::TravelToolInfo* back_info);

  // @@protoc_insertion_point(class_scope:IM.Buddy.TransportTool)
 private:
  inline void set_has_from_info();
  inline void clear_has_from_info();
  inline void set_has_back_info();
  inline void clear_has_back_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::TravelToolInfo* from_info_;
  ::IM::Buddy::TravelToolInfo* back_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static TransportTool* default_instance_;
};
// -------------------------------------------------------------------

class DayScenic : public ::google::protobuf::MessageLite {
 public:
  DayScenic();
  virtual ~DayScenic();

  DayScenic(const DayScenic& from);

  inline DayScenic& operator=(const DayScenic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DayScenic& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DayScenic* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DayScenic* other);

  // implements Message ----------------------------------------------

  DayScenic* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DayScenic& from);
  void MergeFrom(const DayScenic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dayTimeFrom = 1;
  inline bool has_daytimefrom() const;
  inline void clear_daytimefrom();
  static const int kDayTimeFromFieldNumber = 1;
  inline const ::std::string& daytimefrom() const;
  inline void set_daytimefrom(const ::std::string& value);
  inline void set_daytimefrom(const char* value);
  inline void set_daytimefrom(const char* value, size_t size);
  inline ::std::string* mutable_daytimefrom();
  inline ::std::string* release_daytimefrom();
  inline void set_allocated_daytimefrom(::std::string* daytimefrom);

  // required string dayTimeTo = 2;
  inline bool has_daytimeto() const;
  inline void clear_daytimeto();
  static const int kDayTimeToFieldNumber = 2;
  inline const ::std::string& daytimeto() const;
  inline void set_daytimeto(const ::std::string& value);
  inline void set_daytimeto(const char* value);
  inline void set_daytimeto(const char* value, size_t size);
  inline ::std::string* mutable_daytimeto();
  inline ::std::string* release_daytimeto();
  inline void set_allocated_daytimeto(::std::string* daytimeto);

  // required .IM.Buddy.ScenicInfo scenic_info = 3;
  inline bool has_scenic_info() const;
  inline void clear_scenic_info();
  static const int kScenicInfoFieldNumber = 3;
  inline const ::IM::Buddy::ScenicInfo& scenic_info() const;
  inline ::IM::Buddy::ScenicInfo* mutable_scenic_info();
  inline ::IM::Buddy::ScenicInfo* release_scenic_info();
  inline void set_allocated_scenic_info(::IM::Buddy::ScenicInfo* scenic_info);

  // @@protoc_insertion_point(class_scope:IM.Buddy.DayScenic)
 private:
  inline void set_has_daytimefrom();
  inline void clear_has_daytimefrom();
  inline void set_has_daytimeto();
  inline void clear_has_daytimeto();
  inline void set_has_scenic_info();
  inline void clear_has_scenic_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* daytimefrom_;
  ::std::string* daytimeto_;
  ::IM::Buddy::ScenicInfo* scenic_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static DayScenic* default_instance_;
};
// -------------------------------------------------------------------

class DayHotel : public ::google::protobuf::MessageLite {
 public:
  DayHotel();
  virtual ~DayHotel();

  DayHotel(const DayHotel& from);

  inline DayHotel& operator=(const DayHotel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DayHotel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DayHotel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DayHotel* other);

  // implements Message ----------------------------------------------

  DayHotel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DayHotel& from);
  void MergeFrom(const DayHotel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dayTimeFrom = 1;
  inline bool has_daytimefrom() const;
  inline void clear_daytimefrom();
  static const int kDayTimeFromFieldNumber = 1;
  inline const ::std::string& daytimefrom() const;
  inline void set_daytimefrom(const ::std::string& value);
  inline void set_daytimefrom(const char* value);
  inline void set_daytimefrom(const char* value, size_t size);
  inline ::std::string* mutable_daytimefrom();
  inline ::std::string* release_daytimefrom();
  inline void set_allocated_daytimefrom(::std::string* daytimefrom);

  // required string dayTimeTo = 2;
  inline bool has_daytimeto() const;
  inline void clear_daytimeto();
  static const int kDayTimeToFieldNumber = 2;
  inline const ::std::string& daytimeto() const;
  inline void set_daytimeto(const ::std::string& value);
  inline void set_daytimeto(const char* value);
  inline void set_daytimeto(const char* value, size_t size);
  inline ::std::string* mutable_daytimeto();
  inline ::std::string* release_daytimeto();
  inline void set_allocated_daytimeto(::std::string* daytimeto);

  // required .IM.Buddy.HotelInfo hotel_info = 3;
  inline bool has_hotel_info() const;
  inline void clear_hotel_info();
  static const int kHotelInfoFieldNumber = 3;
  inline const ::IM::Buddy::HotelInfo& hotel_info() const;
  inline ::IM::Buddy::HotelInfo* mutable_hotel_info();
  inline ::IM::Buddy::HotelInfo* release_hotel_info();
  inline void set_allocated_hotel_info(::IM::Buddy::HotelInfo* hotel_info);

  // @@protoc_insertion_point(class_scope:IM.Buddy.DayHotel)
 private:
  inline void set_has_daytimefrom();
  inline void clear_has_daytimefrom();
  inline void set_has_daytimeto();
  inline void clear_has_daytimeto();
  inline void set_has_hotel_info();
  inline void clear_has_hotel_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* daytimefrom_;
  ::std::string* daytimeto_;
  ::IM::Buddy::HotelInfo* hotel_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static DayHotel* default_instance_;
};
// -------------------------------------------------------------------

class PlayDetail : public ::google::protobuf::MessageLite {
 public:
  PlayDetail();
  virtual ~PlayDetail();

  PlayDetail(const PlayDetail& from);

  inline PlayDetail& operator=(const PlayDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayDetail* other);

  // implements Message ----------------------------------------------

  PlayDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayDetail& from);
  void MergeFrom(const PlayDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Buddy.PlayConfig play_config = 1;
  inline bool has_play_config() const;
  inline void clear_play_config();
  static const int kPlayConfigFieldNumber = 1;
  inline const ::IM::Buddy::PlayConfig& play_config() const;
  inline ::IM::Buddy::PlayConfig* mutable_play_config();
  inline ::IM::Buddy::PlayConfig* release_play_config();
  inline void set_allocated_play_config(::IM::Buddy::PlayConfig* play_config);

  // repeated .IM.Buddy.DayHotel day_hotel = 2;
  inline int day_hotel_size() const;
  inline void clear_day_hotel();
  static const int kDayHotelFieldNumber = 2;
  inline const ::IM::Buddy::DayHotel& day_hotel(int index) const;
  inline ::IM::Buddy::DayHotel* mutable_day_hotel(int index);
  inline ::IM::Buddy::DayHotel* add_day_hotel();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayHotel >&
      day_hotel() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayHotel >*
      mutable_day_hotel();

  // repeated .IM.Buddy.DayScenic day_scenic = 3;
  inline int day_scenic_size() const;
  inline void clear_day_scenic();
  static const int kDayScenicFieldNumber = 3;
  inline const ::IM::Buddy::DayScenic& day_scenic(int index) const;
  inline ::IM::Buddy::DayScenic* mutable_day_scenic(int index);
  inline ::IM::Buddy::DayScenic* add_day_scenic();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayScenic >&
      day_scenic() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayScenic >*
      mutable_day_scenic();

  // @@protoc_insertion_point(class_scope:IM.Buddy.PlayDetail)
 private:
  inline void set_has_play_config();
  inline void clear_has_play_config();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::PlayConfig* play_config_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayHotel > day_hotel_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayScenic > day_scenic_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static PlayDetail* default_instance_;
};
// -------------------------------------------------------------------

class PlayConfig : public ::google::protobuf::MessageLite {
 public:
  PlayConfig();
  virtual ~PlayConfig();

  PlayConfig(const PlayConfig& from);

  inline PlayConfig& operator=(const PlayConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PlayConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayConfig* other);

  // implements Message ----------------------------------------------

  PlayConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayConfig& from);
  void MergeFrom(const PlayConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Buddy.QualityType quality = 1;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 1;
  inline ::IM::Buddy::QualityType quality() const;
  inline void set_quality(::IM::Buddy::QualityType value);

  // required string time_from = 2;
  inline bool has_time_from() const;
  inline void clear_time_from();
  static const int kTimeFromFieldNumber = 2;
  inline const ::std::string& time_from() const;
  inline void set_time_from(const ::std::string& value);
  inline void set_time_from(const char* value);
  inline void set_time_from(const char* value, size_t size);
  inline ::std::string* mutable_time_from();
  inline ::std::string* release_time_from();
  inline void set_allocated_time_from(::std::string* time_from);

  // required string time_to = 3;
  inline bool has_time_to() const;
  inline void clear_time_to();
  static const int kTimeToFieldNumber = 3;
  inline const ::std::string& time_to() const;
  inline void set_time_to(const ::std::string& value);
  inline void set_time_to(const char* value);
  inline void set_time_to(const char* value, size_t size);
  inline ::std::string* mutable_time_to();
  inline ::std::string* release_time_to();
  inline void set_allocated_time_to(::std::string* time_to);

  // required uint32 transport_tool_type = 4;
  inline bool has_transport_tool_type() const;
  inline void clear_transport_tool_type();
  static const int kTransportToolTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 transport_tool_type() const;
  inline void set_transport_tool_type(::google::protobuf::uint32 value);

  // required .IM.Buddy.PositionType position = 5;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 5;
  inline ::IM::Buddy::PositionType position() const;
  inline void set_position(::IM::Buddy::PositionType value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.PlayConfig)
 private:
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_time_from();
  inline void clear_has_time_from();
  inline void set_has_time_to();
  inline void clear_has_time_to();
  inline void set_has_transport_tool_type();
  inline void clear_has_transport_tool_type();
  inline void set_has_position();
  inline void clear_has_position();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_from_;
  int quality_;
  ::google::protobuf::uint32 transport_tool_type_;
  ::std::string* time_to_;
  int position_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static PlayConfig* default_instance_;
};
// -------------------------------------------------------------------

class ScenicInfo : public ::google::protobuf::MessageLite {
 public:
  ScenicInfo();
  virtual ~ScenicInfo();

  ScenicInfo(const ScenicInfo& from);

  inline ScenicInfo& operator=(const ScenicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ScenicInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ScenicInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ScenicInfo* other);

  // implements Message ----------------------------------------------

  ScenicInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ScenicInfo& from);
  void MergeFrom(const ScenicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string city_code = 2;
  inline bool has_city_code() const;
  inline void clear_city_code();
  static const int kCityCodeFieldNumber = 2;
  inline const ::std::string& city_code() const;
  inline void set_city_code(const ::std::string& value);
  inline void set_city_code(const char* value);
  inline void set_city_code(const char* value, size_t size);
  inline ::std::string* mutable_city_code();
  inline ::std::string* release_city_code();
  inline void set_allocated_city_code(::std::string* city_code);

  // required string sightName = 3;
  inline bool has_sightname() const;
  inline void clear_sightname();
  static const int kSightNameFieldNumber = 3;
  inline const ::std::string& sightname() const;
  inline void set_sightname(const ::std::string& value);
  inline void set_sightname(const char* value);
  inline void set_sightname(const char* value, size_t size);
  inline ::std::string* mutable_sightname();
  inline ::std::string* release_sightname();
  inline void set_allocated_sightname(::std::string* sightname);

  // required uint32 sightScore = 4;
  inline bool has_sightscore() const;
  inline void clear_sightscore();
  static const int kSightScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 sightscore() const;
  inline void set_sightscore(::google::protobuf::uint32 value);

  // required string sightTag = 5;
  inline bool has_sighttag() const;
  inline void clear_sighttag();
  static const int kSightTagFieldNumber = 5;
  inline const ::std::string& sighttag() const;
  inline void set_sighttag(const ::std::string& value);
  inline void set_sighttag(const char* value);
  inline void set_sighttag(const char* value, size_t size);
  inline ::std::string* mutable_sighttag();
  inline ::std::string* release_sighttag();
  inline void set_allocated_sighttag(::std::string* sighttag);

  // required string sightPic = 6;
  inline bool has_sightpic() const;
  inline void clear_sightpic();
  static const int kSightPicFieldNumber = 6;
  inline const ::std::string& sightpic() const;
  inline void set_sightpic(const ::std::string& value);
  inline void set_sightpic(const char* value);
  inline void set_sightpic(const char* value, size_t size);
  inline ::std::string* mutable_sightpic();
  inline ::std::string* release_sightpic();
  inline void set_allocated_sightpic(::std::string* sightpic);

  // required uint32 sightMustSee = 7;
  inline bool has_sightmustsee() const;
  inline void clear_sightmustsee();
  static const int kSightMustSeeFieldNumber = 7;
  inline ::google::protobuf::uint32 sightmustsee() const;
  inline void set_sightmustsee(::google::protobuf::uint32 value);

  // required string sightUrl = 8;
  inline bool has_sighturl() const;
  inline void clear_sighturl();
  static const int kSightUrlFieldNumber = 8;
  inline const ::std::string& sighturl() const;
  inline void set_sighturl(const ::std::string& value);
  inline void set_sighturl(const char* value);
  inline void set_sighturl(const char* value, size_t size);
  inline ::std::string* mutable_sighturl();
  inline ::std::string* release_sighturl();
  inline void set_allocated_sighturl(::std::string* sighturl);

  // required string sightOpenTime = 9;
  inline bool has_sightopentime() const;
  inline void clear_sightopentime();
  static const int kSightOpenTimeFieldNumber = 9;
  inline const ::std::string& sightopentime() const;
  inline void set_sightopentime(const ::std::string& value);
  inline void set_sightopentime(const char* value);
  inline void set_sightopentime(const char* value, size_t size);
  inline ::std::string* mutable_sightopentime();
  inline ::std::string* release_sightopentime();
  inline void set_allocated_sightopentime(::std::string* sightopentime);

  // required uint32 sightPlayTime = 10;
  inline bool has_sightplaytime() const;
  inline void clear_sightplaytime();
  static const int kSightPlayTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 sightplaytime() const;
  inline void set_sightplaytime(::google::protobuf::uint32 value);

  // required uint32 sightPrice = 11;
  inline bool has_sightprice() const;
  inline void clear_sightprice();
  static const int kSightPriceFieldNumber = 11;
  inline ::google::protobuf::uint32 sightprice() const;
  inline void set_sightprice(::google::protobuf::uint32 value);

  // required string sightStartTime = 12;
  inline bool has_sightstarttime() const;
  inline void clear_sightstarttime();
  static const int kSightStartTimeFieldNumber = 12;
  inline const ::std::string& sightstarttime() const;
  inline void set_sightstarttime(const ::std::string& value);
  inline void set_sightstarttime(const char* value);
  inline void set_sightstarttime(const char* value, size_t size);
  inline ::std::string* mutable_sightstarttime();
  inline ::std::string* release_sightstarttime();
  inline void set_allocated_sightstarttime(::std::string* sightstarttime);

  // required string sightEndTime = 13;
  inline bool has_sightendtime() const;
  inline void clear_sightendtime();
  static const int kSightEndTimeFieldNumber = 13;
  inline const ::std::string& sightendtime() const;
  inline void set_sightendtime(const ::std::string& value);
  inline void set_sightendtime(const char* value);
  inline void set_sightendtime(const char* value, size_t size);
  inline ::std::string* mutable_sightendtime();
  inline ::std::string* release_sightendtime();
  inline void set_allocated_sightendtime(::std::string* sightendtime);

  // required string sightLongitude = 14;
  inline bool has_sightlongitude() const;
  inline void clear_sightlongitude();
  static const int kSightLongitudeFieldNumber = 14;
  inline const ::std::string& sightlongitude() const;
  inline void set_sightlongitude(const ::std::string& value);
  inline void set_sightlongitude(const char* value);
  inline void set_sightlongitude(const char* value, size_t size);
  inline ::std::string* mutable_sightlongitude();
  inline ::std::string* release_sightlongitude();
  inline void set_allocated_sightlongitude(::std::string* sightlongitude);

  // required string sightLatitude = 15;
  inline bool has_sightlatitude() const;
  inline void clear_sightlatitude();
  static const int kSightLatitudeFieldNumber = 15;
  inline const ::std::string& sightlatitude() const;
  inline void set_sightlatitude(const ::std::string& value);
  inline void set_sightlatitude(const char* value);
  inline void set_sightlatitude(const char* value, size_t size);
  inline ::std::string* mutable_sightlatitude();
  inline ::std::string* release_sightlatitude();
  inline void set_allocated_sightlatitude(::std::string* sightlatitude);

  // required string sightAddress = 16;
  inline bool has_sightaddress() const;
  inline void clear_sightaddress();
  static const int kSightAddressFieldNumber = 16;
  inline const ::std::string& sightaddress() const;
  inline void set_sightaddress(const ::std::string& value);
  inline void set_sightaddress(const char* value);
  inline void set_sightaddress(const char* value, size_t size);
  inline ::std::string* mutable_sightaddress();
  inline ::std::string* release_sightaddress();
  inline void set_allocated_sightaddress(::std::string* sightaddress);

  // required string sightDiscription = 17;
  inline bool has_sightdiscription() const;
  inline void clear_sightdiscription();
  static const int kSightDiscriptionFieldNumber = 17;
  inline const ::std::string& sightdiscription() const;
  inline void set_sightdiscription(const ::std::string& value);
  inline void set_sightdiscription(const char* value);
  inline void set_sightdiscription(const char* value, size_t size);
  inline ::std::string* mutable_sightdiscription();
  inline ::std::string* release_sightdiscription();
  inline void set_allocated_sightdiscription(::std::string* sightdiscription);

  // required string sightDiscriptionDetail = 18;
  inline bool has_sightdiscriptiondetail() const;
  inline void clear_sightdiscriptiondetail();
  static const int kSightDiscriptionDetailFieldNumber = 18;
  inline const ::std::string& sightdiscriptiondetail() const;
  inline void set_sightdiscriptiondetail(const ::std::string& value);
  inline void set_sightdiscriptiondetail(const char* value);
  inline void set_sightdiscriptiondetail(const char* value, size_t size);
  inline ::std::string* mutable_sightdiscriptiondetail();
  inline ::std::string* release_sightdiscriptiondetail();
  inline void set_allocated_sightdiscriptiondetail(::std::string* sightdiscriptiondetail);

  // required uint32 sightStatus = 19;
  inline bool has_sightstatus() const;
  inline void clear_sightstatus();
  static const int kSightStatusFieldNumber = 19;
  inline ::google::protobuf::uint32 sightstatus() const;
  inline void set_sightstatus(::google::protobuf::uint32 value);

  // required uint32 literature = 20;
  inline bool has_literature() const;
  inline void clear_literature();
  static const int kLiteratureFieldNumber = 20;
  inline ::google::protobuf::uint32 literature() const;
  inline void set_literature(::google::protobuf::uint32 value);

  // required uint32 comfort = 21;
  inline bool has_comfort() const;
  inline void clear_comfort();
  static const int kComfortFieldNumber = 21;
  inline ::google::protobuf::uint32 comfort() const;
  inline void set_comfort(::google::protobuf::uint32 value);

  // required uint32 exploration = 22;
  inline bool has_exploration() const;
  inline void clear_exploration();
  static const int kExplorationFieldNumber = 22;
  inline ::google::protobuf::uint32 exploration() const;
  inline void set_exploration(::google::protobuf::uint32 value);

  // required uint32 excite = 23;
  inline bool has_excite() const;
  inline void clear_excite();
  static const int kExciteFieldNumber = 23;
  inline ::google::protobuf::uint32 excite() const;
  inline void set_excite(::google::protobuf::uint32 value);

  // required uint32 encounter = 24;
  inline bool has_encounter() const;
  inline void clear_encounter();
  static const int kEncounterFieldNumber = 24;
  inline ::google::protobuf::uint32 encounter() const;
  inline void set_encounter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.ScenicInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_city_code();
  inline void clear_has_city_code();
  inline void set_has_sightname();
  inline void clear_has_sightname();
  inline void set_has_sightscore();
  inline void clear_has_sightscore();
  inline void set_has_sighttag();
  inline void clear_has_sighttag();
  inline void set_has_sightpic();
  inline void clear_has_sightpic();
  inline void set_has_sightmustsee();
  inline void clear_has_sightmustsee();
  inline void set_has_sighturl();
  inline void clear_has_sighturl();
  inline void set_has_sightopentime();
  inline void clear_has_sightopentime();
  inline void set_has_sightplaytime();
  inline void clear_has_sightplaytime();
  inline void set_has_sightprice();
  inline void clear_has_sightprice();
  inline void set_has_sightstarttime();
  inline void clear_has_sightstarttime();
  inline void set_has_sightendtime();
  inline void clear_has_sightendtime();
  inline void set_has_sightlongitude();
  inline void clear_has_sightlongitude();
  inline void set_has_sightlatitude();
  inline void clear_has_sightlatitude();
  inline void set_has_sightaddress();
  inline void clear_has_sightaddress();
  inline void set_has_sightdiscription();
  inline void clear_has_sightdiscription();
  inline void set_has_sightdiscriptiondetail();
  inline void clear_has_sightdiscriptiondetail();
  inline void set_has_sightstatus();
  inline void clear_has_sightstatus();
  inline void set_has_literature();
  inline void clear_has_literature();
  inline void set_has_comfort();
  inline void clear_has_comfort();
  inline void set_has_exploration();
  inline void clear_has_exploration();
  inline void set_has_excite();
  inline void clear_has_excite();
  inline void set_has_encounter();
  inline void clear_has_encounter();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_code_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 sightscore_;
  ::std::string* sightname_;
  ::std::string* sighttag_;
  ::std::string* sightpic_;
  ::std::string* sighturl_;
  ::google::protobuf::uint32 sightmustsee_;
  ::google::protobuf::uint32 sightplaytime_;
  ::std::string* sightopentime_;
  ::std::string* sightstarttime_;
  ::std::string* sightendtime_;
  ::std::string* sightlongitude_;
  ::std::string* sightlatitude_;
  ::google::protobuf::uint32 sightprice_;
  ::google::protobuf::uint32 sightstatus_;
  ::std::string* sightaddress_;
  ::std::string* sightdiscription_;
  ::std::string* sightdiscriptiondetail_;
  ::google::protobuf::uint32 literature_;
  ::google::protobuf::uint32 comfort_;
  ::google::protobuf::uint32 exploration_;
  ::google::protobuf::uint32 excite_;
  ::google::protobuf::uint32 encounter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static ScenicInfo* default_instance_;
};
// -------------------------------------------------------------------

class HotelInfo : public ::google::protobuf::MessageLite {
 public:
  HotelInfo();
  virtual ~HotelInfo();

  HotelInfo(const HotelInfo& from);

  inline HotelInfo& operator=(const HotelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HotelInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HotelInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HotelInfo* other);

  // implements Message ----------------------------------------------

  HotelInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HotelInfo& from);
  void MergeFrom(const HotelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string city_code = 2;
  inline bool has_city_code() const;
  inline void clear_city_code();
  static const int kCityCodeFieldNumber = 2;
  inline const ::std::string& city_code() const;
  inline void set_city_code(const ::std::string& value);
  inline void set_city_code(const char* value);
  inline void set_city_code(const char* value, size_t size);
  inline ::std::string* mutable_city_code();
  inline ::std::string* release_city_code();
  inline void set_allocated_city_code(::std::string* city_code);

  // required string hotelName = 3;
  inline bool has_hotelname() const;
  inline void clear_hotelname();
  static const int kHotelNameFieldNumber = 3;
  inline const ::std::string& hotelname() const;
  inline void set_hotelname(const ::std::string& value);
  inline void set_hotelname(const char* value);
  inline void set_hotelname(const char* value, size_t size);
  inline ::std::string* mutable_hotelname();
  inline ::std::string* release_hotelname();
  inline void set_allocated_hotelname(::std::string* hotelname);

  // required uint32 hotelScore = 4;
  inline bool has_hotelscore() const;
  inline void clear_hotelscore();
  static const int kHotelScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 hotelscore() const;
  inline void set_hotelscore(::google::protobuf::uint32 value);

  // required string hotelTag = 5;
  inline bool has_hoteltag() const;
  inline void clear_hoteltag();
  static const int kHotelTagFieldNumber = 5;
  inline const ::std::string& hoteltag() const;
  inline void set_hoteltag(const ::std::string& value);
  inline void set_hoteltag(const char* value);
  inline void set_hoteltag(const char* value, size_t size);
  inline ::std::string* mutable_hoteltag();
  inline ::std::string* release_hoteltag();
  inline void set_allocated_hoteltag(::std::string* hoteltag);

  // required string hotelPic = 6;
  inline bool has_hotelpic() const;
  inline void clear_hotelpic();
  static const int kHotelPicFieldNumber = 6;
  inline const ::std::string& hotelpic() const;
  inline void set_hotelpic(const ::std::string& value);
  inline void set_hotelpic(const char* value);
  inline void set_hotelpic(const char* value, size_t size);
  inline ::std::string* mutable_hotelpic();
  inline ::std::string* release_hotelpic();
  inline void set_allocated_hotelpic(::std::string* hotelpic);

  // required string hotelUrl = 7;
  inline bool has_hotelurl() const;
  inline void clear_hotelurl();
  static const int kHotelUrlFieldNumber = 7;
  inline const ::std::string& hotelurl() const;
  inline void set_hotelurl(const ::std::string& value);
  inline void set_hotelurl(const char* value);
  inline void set_hotelurl(const char* value, size_t size);
  inline ::std::string* mutable_hotelurl();
  inline ::std::string* release_hotelurl();
  inline void set_allocated_hotelurl(::std::string* hotelurl);

  // required uint32 hotelPrice = 8;
  inline bool has_hotelprice() const;
  inline void clear_hotelprice();
  static const int kHotelPriceFieldNumber = 8;
  inline ::google::protobuf::uint32 hotelprice() const;
  inline void set_hotelprice(::google::protobuf::uint32 value);

  // required string hotelLongitude = 9;
  inline bool has_hotellongitude() const;
  inline void clear_hotellongitude();
  static const int kHotelLongitudeFieldNumber = 9;
  inline const ::std::string& hotellongitude() const;
  inline void set_hotellongitude(const ::std::string& value);
  inline void set_hotellongitude(const char* value);
  inline void set_hotellongitude(const char* value, size_t size);
  inline ::std::string* mutable_hotellongitude();
  inline ::std::string* release_hotellongitude();
  inline void set_allocated_hotellongitude(::std::string* hotellongitude);

  // required string hotelLatitude = 10;
  inline bool has_hotellatitude() const;
  inline void clear_hotellatitude();
  static const int kHotelLatitudeFieldNumber = 10;
  inline const ::std::string& hotellatitude() const;
  inline void set_hotellatitude(const ::std::string& value);
  inline void set_hotellatitude(const char* value);
  inline void set_hotellatitude(const char* value, size_t size);
  inline ::std::string* mutable_hotellatitude();
  inline ::std::string* release_hotellatitude();
  inline void set_allocated_hotellatitude(::std::string* hotellatitude);

  // @@protoc_insertion_point(class_scope:IM.Buddy.HotelInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_city_code();
  inline void clear_has_city_code();
  inline void set_has_hotelname();
  inline void clear_has_hotelname();
  inline void set_has_hotelscore();
  inline void clear_has_hotelscore();
  inline void set_has_hoteltag();
  inline void clear_has_hoteltag();
  inline void set_has_hotelpic();
  inline void clear_has_hotelpic();
  inline void set_has_hotelurl();
  inline void clear_has_hotelurl();
  inline void set_has_hotelprice();
  inline void clear_has_hotelprice();
  inline void set_has_hotellongitude();
  inline void clear_has_hotellongitude();
  inline void set_has_hotellatitude();
  inline void clear_has_hotellatitude();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_code_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 hotelscore_;
  ::std::string* hotelname_;
  ::std::string* hoteltag_;
  ::std::string* hotelpic_;
  ::std::string* hotelurl_;
  ::std::string* hotellongitude_;
  ::std::string* hotellatitude_;
  ::google::protobuf::uint32 hotelprice_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static HotelInfo* default_instance_;
};
// -------------------------------------------------------------------

class MyTravel : public ::google::protobuf::MessageLite {
 public:
  MyTravel();
  virtual ~MyTravel();

  MyTravel(const MyTravel& from);

  inline MyTravel& operator=(const MyTravel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MyTravel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MyTravel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MyTravel* other);

  // implements Message ----------------------------------------------

  MyTravel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MyTravel& from);
  void MergeFrom(const MyTravel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 db_idx = 1;
  inline bool has_db_idx() const;
  inline void clear_db_idx();
  static const int kDbIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 db_idx() const;
  inline void set_db_idx(::google::protobuf::uint32 value);

  // required uint32 cost = 2;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 2;
  inline ::google::protobuf::uint32 cost() const;
  inline void set_cost(::google::protobuf::uint32 value);

  // required .IM.Buddy.BasicInfo basic_info = 3;
  inline bool has_basic_info() const;
  inline void clear_basic_info();
  static const int kBasicInfoFieldNumber = 3;
  inline const ::IM::Buddy::BasicInfo& basic_info() const;
  inline ::IM::Buddy::BasicInfo* mutable_basic_info();
  inline ::IM::Buddy::BasicInfo* release_basic_info();
  inline void set_allocated_basic_info(::IM::Buddy::BasicInfo* basic_info);

  // required .IM.Buddy.TransportConfig transport_config = 4;
  inline bool has_transport_config() const;
  inline void clear_transport_config();
  static const int kTransportConfigFieldNumber = 4;
  inline const ::IM::Buddy::TransportConfig& transport_config() const;
  inline ::IM::Buddy::TransportConfig* mutable_transport_config();
  inline ::IM::Buddy::TransportConfig* release_transport_config();
  inline void set_allocated_transport_config(::IM::Buddy::TransportConfig* transport_config);

  // required .IM.Buddy.TravelDetail travel_detail = 5;
  inline bool has_travel_detail() const;
  inline void clear_travel_detail();
  static const int kTravelDetailFieldNumber = 5;
  inline const ::IM::Buddy::TravelDetail& travel_detail() const;
  inline ::IM::Buddy::TravelDetail* mutable_travel_detail();
  inline ::IM::Buddy::TravelDetail* release_travel_detail();
  inline void set_allocated_travel_detail(::IM::Buddy::TravelDetail* travel_detail);

  // @@protoc_insertion_point(class_scope:IM.Buddy.MyTravel)
 private:
  inline void set_has_db_idx();
  inline void clear_has_db_idx();
  inline void set_has_cost();
  inline void clear_has_cost();
  inline void set_has_basic_info();
  inline void clear_has_basic_info();
  inline void set_has_transport_config();
  inline void clear_has_transport_config();
  inline void set_has_travel_detail();
  inline void clear_has_travel_detail();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 db_idx_;
  ::google::protobuf::uint32 cost_;
  ::IM::Buddy::BasicInfo* basic_info_;
  ::IM::Buddy::TransportConfig* transport_config_;
  ::IM::Buddy::TravelDetail* travel_detail_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static MyTravel* default_instance_;
};
// -------------------------------------------------------------------

class CreateMyTravelReq : public ::google::protobuf::MessageLite {
 public:
  CreateMyTravelReq();
  virtual ~CreateMyTravelReq();

  CreateMyTravelReq(const CreateMyTravelReq& from);

  inline CreateMyTravelReq& operator=(const CreateMyTravelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateMyTravelReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateMyTravelReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateMyTravelReq* other);

  // implements Message ----------------------------------------------

  CreateMyTravelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateMyTravelReq& from);
  void MergeFrom(const CreateMyTravelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.Buddy.MyTravel my_travel = 2;
  inline bool has_my_travel() const;
  inline void clear_my_travel();
  static const int kMyTravelFieldNumber = 2;
  inline const ::IM::Buddy::MyTravel& my_travel() const;
  inline ::IM::Buddy::MyTravel* mutable_my_travel();
  inline ::IM::Buddy::MyTravel* release_my_travel();
  inline void set_allocated_my_travel(::IM::Buddy::MyTravel* my_travel);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.CreateMyTravelReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_my_travel();
  inline void clear_has_my_travel();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::MyTravel* my_travel_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static CreateMyTravelReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateMyTravelRsp : public ::google::protobuf::MessageLite {
 public:
  CreateMyTravelRsp();
  virtual ~CreateMyTravelRsp();

  CreateMyTravelRsp(const CreateMyTravelRsp& from);

  inline CreateMyTravelRsp& operator=(const CreateMyTravelRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateMyTravelRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateMyTravelRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateMyTravelRsp* other);

  // implements Message ----------------------------------------------

  CreateMyTravelRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateMyTravelRsp& from);
  void MergeFrom(const CreateMyTravelRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required uint32 db_idx = 3;
  inline bool has_db_idx() const;
  inline void clear_db_idx();
  static const int kDbIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 db_idx() const;
  inline void set_db_idx(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.CreateMyTravelRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_db_idx();
  inline void clear_has_db_idx();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 db_idx_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static CreateMyTravelRsp* default_instance_;
};
// -------------------------------------------------------------------

class DeleteMyTravelReq : public ::google::protobuf::MessageLite {
 public:
  DeleteMyTravelReq();
  virtual ~DeleteMyTravelReq();

  DeleteMyTravelReq(const DeleteMyTravelReq& from);

  inline DeleteMyTravelReq& operator=(const DeleteMyTravelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteMyTravelReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteMyTravelReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteMyTravelReq* other);

  // implements Message ----------------------------------------------

  DeleteMyTravelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteMyTravelReq& from);
  void MergeFrom(const DeleteMyTravelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 db_idx = 2;
  inline int db_idx_size() const;
  inline void clear_db_idx();
  static const int kDbIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 db_idx(int index) const;
  inline void set_db_idx(int index, ::google::protobuf::uint32 value);
  inline void add_db_idx(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      db_idx() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_db_idx();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.DeleteMyTravelReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > db_idx_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static DeleteMyTravelReq* default_instance_;
};
// -------------------------------------------------------------------

class DeleteMyTravelRsp : public ::google::protobuf::MessageLite {
 public:
  DeleteMyTravelRsp();
  virtual ~DeleteMyTravelRsp();

  DeleteMyTravelRsp(const DeleteMyTravelRsp& from);

  inline DeleteMyTravelRsp& operator=(const DeleteMyTravelRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteMyTravelRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteMyTravelRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteMyTravelRsp* other);

  // implements Message ----------------------------------------------

  DeleteMyTravelRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteMyTravelRsp& from);
  void MergeFrom(const DeleteMyTravelRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.DeleteMyTravelRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static DeleteMyTravelRsp* default_instance_;
};
// -------------------------------------------------------------------

class UpdateMyTravelReq : public ::google::protobuf::MessageLite {
 public:
  UpdateMyTravelReq();
  virtual ~UpdateMyTravelReq();

  UpdateMyTravelReq(const UpdateMyTravelReq& from);

  inline UpdateMyTravelReq& operator=(const UpdateMyTravelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateMyTravelReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateMyTravelReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateMyTravelReq* other);

  // implements Message ----------------------------------------------

  UpdateMyTravelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateMyTravelReq& from);
  void MergeFrom(const UpdateMyTravelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 db_idx = 2;
  inline bool has_db_idx() const;
  inline void clear_db_idx();
  static const int kDbIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 db_idx() const;
  inline void set_db_idx(::google::protobuf::uint32 value);

  // required .IM.Buddy.MyTravel my_travel = 3;
  inline bool has_my_travel() const;
  inline void clear_my_travel();
  static const int kMyTravelFieldNumber = 3;
  inline const ::IM::Buddy::MyTravel& my_travel() const;
  inline ::IM::Buddy::MyTravel* mutable_my_travel();
  inline ::IM::Buddy::MyTravel* release_my_travel();
  inline void set_allocated_my_travel(::IM::Buddy::MyTravel* my_travel);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.UpdateMyTravelReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_db_idx();
  inline void clear_has_db_idx();
  inline void set_has_my_travel();
  inline void clear_has_my_travel();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 db_idx_;
  ::IM::Buddy::MyTravel* my_travel_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static UpdateMyTravelReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateMyTravelRsp : public ::google::protobuf::MessageLite {
 public:
  UpdateMyTravelRsp();
  virtual ~UpdateMyTravelRsp();

  UpdateMyTravelRsp(const UpdateMyTravelRsp& from);

  inline UpdateMyTravelRsp& operator=(const UpdateMyTravelRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateMyTravelRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateMyTravelRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateMyTravelRsp* other);

  // implements Message ----------------------------------------------

  UpdateMyTravelRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateMyTravelRsp& from);
  void MergeFrom(const UpdateMyTravelRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.UpdateMyTravelRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static UpdateMyTravelRsp* default_instance_;
};
// -------------------------------------------------------------------

class QueryMyTravelReq : public ::google::protobuf::MessageLite {
 public:
  QueryMyTravelReq();
  virtual ~QueryMyTravelReq();

  QueryMyTravelReq(const QueryMyTravelReq& from);

  inline QueryMyTravelReq& operator=(const QueryMyTravelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QueryMyTravelReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryMyTravelReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryMyTravelReq* other);

  // implements Message ----------------------------------------------

  QueryMyTravelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryMyTravelReq& from);
  void MergeFrom(const QueryMyTravelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.QueryMyTravelReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static QueryMyTravelReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryMyTravelRsp : public ::google::protobuf::MessageLite {
 public:
  QueryMyTravelRsp();
  virtual ~QueryMyTravelRsp();

  QueryMyTravelRsp(const QueryMyTravelRsp& from);

  inline QueryMyTravelRsp& operator=(const QueryMyTravelRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const QueryMyTravelRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryMyTravelRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryMyTravelRsp* other);

  // implements Message ----------------------------------------------

  QueryMyTravelRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryMyTravelRsp& from);
  void MergeFrom(const QueryMyTravelRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.MyTravel my_travel = 3;
  inline int my_travel_size() const;
  inline void clear_my_travel();
  static const int kMyTravelFieldNumber = 3;
  inline const ::IM::Buddy::MyTravel& my_travel(int index) const;
  inline ::IM::Buddy::MyTravel* mutable_my_travel(int index);
  inline ::IM::Buddy::MyTravel* add_my_travel();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::MyTravel >&
      my_travel() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::MyTravel >*
      mutable_my_travel();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.QueryMyTravelRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::MyTravel > my_travel_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static QueryMyTravelRsp* default_instance_;
};
// -------------------------------------------------------------------

class GetTransportToolReq : public ::google::protobuf::MessageLite {
 public:
  GetTransportToolReq();
  virtual ~GetTransportToolReq();

  GetTransportToolReq(const GetTransportToolReq& from);

  inline GetTransportToolReq& operator=(const GetTransportToolReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTransportToolReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTransportToolReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTransportToolReq* other);

  // implements Message ----------------------------------------------

  GetTransportToolReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTransportToolReq& from);
  void MergeFrom(const GetTransportToolReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.Buddy.BasicInfo basic_info = 2;
  inline bool has_basic_info() const;
  inline void clear_basic_info();
  static const int kBasicInfoFieldNumber = 2;
  inline const ::IM::Buddy::BasicInfo& basic_info() const;
  inline ::IM::Buddy::BasicInfo* mutable_basic_info();
  inline ::IM::Buddy::BasicInfo* release_basic_info();
  inline void set_allocated_basic_info(::IM::Buddy::BasicInfo* basic_info);

  // required .IM.Buddy.TransportConfig transport_config = 3;
  inline bool has_transport_config() const;
  inline void clear_transport_config();
  static const int kTransportConfigFieldNumber = 3;
  inline const ::IM::Buddy::TransportConfig& transport_config() const;
  inline ::IM::Buddy::TransportConfig* mutable_transport_config();
  inline ::IM::Buddy::TransportConfig* release_transport_config();
  inline void set_allocated_transport_config(::IM::Buddy::TransportConfig* transport_config);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.GetTransportToolReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_basic_info();
  inline void clear_has_basic_info();
  inline void set_has_transport_config();
  inline void clear_has_transport_config();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::BasicInfo* basic_info_;
  ::IM::Buddy::TransportConfig* transport_config_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static GetTransportToolReq* default_instance_;
};
// -------------------------------------------------------------------

class GetTransportToolRsp : public ::google::protobuf::MessageLite {
 public:
  GetTransportToolRsp();
  virtual ~GetTransportToolRsp();

  GetTransportToolRsp(const GetTransportToolRsp& from);

  inline GetTransportToolRsp& operator=(const GetTransportToolRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTransportToolRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTransportToolRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTransportToolRsp* other);

  // implements Message ----------------------------------------------

  GetTransportToolRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTransportToolRsp& from);
  void MergeFrom(const GetTransportToolRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.TravelToolInfo travel_tool_info = 3;
  inline int travel_tool_info_size() const;
  inline void clear_travel_tool_info();
  static const int kTravelToolInfoFieldNumber = 3;
  inline const ::IM::Buddy::TravelToolInfo& travel_tool_info(int index) const;
  inline ::IM::Buddy::TravelToolInfo* mutable_travel_tool_info(int index);
  inline ::IM::Buddy::TravelToolInfo* add_travel_tool_info();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >&
      travel_tool_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >*
      mutable_travel_tool_info();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.GetTransportToolRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo > travel_tool_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static GetTransportToolRsp* default_instance_;
};
// -------------------------------------------------------------------

class GetScenicHotelReq : public ::google::protobuf::MessageLite {
 public:
  GetScenicHotelReq();
  virtual ~GetScenicHotelReq();

  GetScenicHotelReq(const GetScenicHotelReq& from);

  inline GetScenicHotelReq& operator=(const GetScenicHotelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetScenicHotelReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetScenicHotelReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetScenicHotelReq* other);

  // implements Message ----------------------------------------------

  GetScenicHotelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetScenicHotelReq& from);
  void MergeFrom(const GetScenicHotelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string city_code = 2;
  inline bool has_city_code() const;
  inline void clear_city_code();
  static const int kCityCodeFieldNumber = 2;
  inline const ::std::string& city_code() const;
  inline void set_city_code(const ::std::string& value);
  inline void set_city_code(const char* value);
  inline void set_city_code(const char* value, size_t size);
  inline ::std::string* mutable_city_code();
  inline ::std::string* release_city_code();
  inline void set_allocated_city_code(::std::string* city_code);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.GetScenicHotelReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_city_code();
  inline void clear_has_city_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* city_code_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static GetScenicHotelReq* default_instance_;
};
// -------------------------------------------------------------------

class GetScenicHotelRsp : public ::google::protobuf::MessageLite {
 public:
  GetScenicHotelRsp();
  virtual ~GetScenicHotelRsp();

  GetScenicHotelRsp(const GetScenicHotelRsp& from);

  inline GetScenicHotelRsp& operator=(const GetScenicHotelRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetScenicHotelRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetScenicHotelRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetScenicHotelRsp* other);

  // implements Message ----------------------------------------------

  GetScenicHotelRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetScenicHotelRsp& from);
  void MergeFrom(const GetScenicHotelRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.ScenicInfo scenic_info = 3;
  inline int scenic_info_size() const;
  inline void clear_scenic_info();
  static const int kScenicInfoFieldNumber = 3;
  inline const ::IM::Buddy::ScenicInfo& scenic_info(int index) const;
  inline ::IM::Buddy::ScenicInfo* mutable_scenic_info(int index);
  inline ::IM::Buddy::ScenicInfo* add_scenic_info();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::ScenicInfo >&
      scenic_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::ScenicInfo >*
      mutable_scenic_info();

  // repeated .IM.Buddy.HotelInfo hotel_info = 4;
  inline int hotel_info_size() const;
  inline void clear_hotel_info();
  static const int kHotelInfoFieldNumber = 4;
  inline const ::IM::Buddy::HotelInfo& hotel_info(int index) const;
  inline ::IM::Buddy::HotelInfo* mutable_hotel_info(int index);
  inline ::IM::Buddy::HotelInfo* add_hotel_info();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::HotelInfo >&
      hotel_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::HotelInfo >*
      mutable_hotel_info();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.GetScenicHotelRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::ScenicInfo > scenic_info_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::HotelInfo > hotel_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static GetScenicHotelRsp* default_instance_;
};
// -------------------------------------------------------------------

class DayRoute : public ::google::protobuf::MessageLite {
 public:
  DayRoute();
  virtual ~DayRoute();

  DayRoute(const DayRoute& from);

  inline DayRoute& operator=(const DayRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DayRoute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DayRoute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DayRoute* other);

  // implements Message ----------------------------------------------

  DayRoute* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DayRoute& from);
  void MergeFrom(const DayRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 scenics = 1;
  inline int scenics_size() const;
  inline void clear_scenics();
  static const int kScenicsFieldNumber = 1;
  inline ::google::protobuf::uint32 scenics(int index) const;
  inline void set_scenics(int index, ::google::protobuf::uint32 value);
  inline void add_scenics(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      scenics() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_scenics();

  // repeated uint32 hotels = 2;
  inline int hotels_size() const;
  inline void clear_hotels();
  static const int kHotelsFieldNumber = 2;
  inline ::google::protobuf::uint32 hotels(int index) const;
  inline void set_hotels(int index, ::google::protobuf::uint32 value);
  inline void add_hotels(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hotels() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hotels();

  // @@protoc_insertion_point(class_scope:IM.Buddy.DayRoute)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > scenics_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hotels_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static DayRoute* default_instance_;
};
// -------------------------------------------------------------------

class Route : public ::google::protobuf::MessageLite {
 public:
  Route();
  virtual ~Route();

  Route(const Route& from);

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Route& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Route* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Route* other);

  // implements Message ----------------------------------------------

  Route* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Route& from);
  void MergeFrom(const Route& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 day_count = 2;
  inline bool has_day_count() const;
  inline void clear_day_count();
  static const int kDayCountFieldNumber = 2;
  inline ::google::protobuf::uint32 day_count() const;
  inline void set_day_count(::google::protobuf::uint32 value);

  // required string city_code = 3;
  inline bool has_city_code() const;
  inline void clear_city_code();
  static const int kCityCodeFieldNumber = 3;
  inline const ::std::string& city_code() const;
  inline void set_city_code(const ::std::string& value);
  inline void set_city_code(const char* value);
  inline void set_city_code(const char* value, size_t size);
  inline ::std::string* mutable_city_code();
  inline ::std::string* release_city_code();
  inline void set_allocated_city_code(::std::string* city_code);

  // repeated string tag = 4;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 4;
  inline const ::std::string& tag(int index) const;
  inline ::std::string* mutable_tag(int index);
  inline void set_tag(int index, const ::std::string& value);
  inline void set_tag(int index, const char* value);
  inline void set_tag(int index, const char* value, size_t size);
  inline ::std::string* add_tag();
  inline void add_tag(const ::std::string& value);
  inline void add_tag(const char* value);
  inline void add_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag();

  // required .IM.Buddy.TransportToolType start_transport_tool = 5;
  inline bool has_start_transport_tool() const;
  inline void clear_start_transport_tool();
  static const int kStartTransportToolFieldNumber = 5;
  inline ::IM::Buddy::TransportToolType start_transport_tool() const;
  inline void set_start_transport_tool(::IM::Buddy::TransportToolType value);

  // required .IM.Buddy.TransportToolType end_transport_tool = 6;
  inline bool has_end_transport_tool() const;
  inline void clear_end_transport_tool();
  static const int kEndTransportToolFieldNumber = 6;
  inline ::IM::Buddy::TransportToolType end_transport_tool() const;
  inline void set_end_transport_tool(::IM::Buddy::TransportToolType value);

  // required string start_time = 7;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 7;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  inline void set_allocated_start_time(::std::string* start_time);

  // required string end_time = 8;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 8;
  inline const ::std::string& end_time() const;
  inline void set_end_time(const ::std::string& value);
  inline void set_end_time(const char* value);
  inline void set_end_time(const char* value, size_t size);
  inline ::std::string* mutable_end_time();
  inline ::std::string* release_end_time();
  inline void set_allocated_end_time(::std::string* end_time);

  // repeated .IM.Buddy.DayRoute day_routes = 9;
  inline int day_routes_size() const;
  inline void clear_day_routes();
  static const int kDayRoutesFieldNumber = 9;
  inline const ::IM::Buddy::DayRoute& day_routes(int index) const;
  inline ::IM::Buddy::DayRoute* mutable_day_routes(int index);
  inline ::IM::Buddy::DayRoute* add_day_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayRoute >&
      day_routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayRoute >*
      mutable_day_routes();

  // @@protoc_insertion_point(class_scope:IM.Buddy.Route)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_day_count();
  inline void clear_has_day_count();
  inline void set_has_city_code();
  inline void clear_has_city_code();
  inline void set_has_start_transport_tool();
  inline void clear_has_start_transport_tool();
  inline void set_has_end_transport_tool();
  inline void clear_has_end_transport_tool();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 day_count_;
  ::std::string* city_code_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_;
  int start_transport_tool_;
  int end_transport_tool_;
  ::std::string* start_time_;
  ::std::string* end_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayRoute > day_routes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static Route* default_instance_;
};
// -------------------------------------------------------------------

class CollectionRoute : public ::google::protobuf::MessageLite {
 public:
  CollectionRoute();
  virtual ~CollectionRoute();

  CollectionRoute(const CollectionRoute& from);

  inline CollectionRoute& operator=(const CollectionRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CollectionRoute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollectionRoute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CollectionRoute* other);

  // implements Message ----------------------------------------------

  CollectionRoute* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollectionRoute& from);
  void MergeFrom(const CollectionRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string start_date = 2;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 2;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const char* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // required string end_date = 3;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 3;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const char* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  inline void set_allocated_end_date(::std::string* end_date);

  // required string start_traffic_no = 4;
  inline bool has_start_traffic_no() const;
  inline void clear_start_traffic_no();
  static const int kStartTrafficNoFieldNumber = 4;
  inline const ::std::string& start_traffic_no() const;
  inline void set_start_traffic_no(const ::std::string& value);
  inline void set_start_traffic_no(const char* value);
  inline void set_start_traffic_no(const char* value, size_t size);
  inline ::std::string* mutable_start_traffic_no();
  inline ::std::string* release_start_traffic_no();
  inline void set_allocated_start_traffic_no(::std::string* start_traffic_no);

  // required string end_traffic_no = 5;
  inline bool has_end_traffic_no() const;
  inline void clear_end_traffic_no();
  static const int kEndTrafficNoFieldNumber = 5;
  inline const ::std::string& end_traffic_no() const;
  inline void set_end_traffic_no(const ::std::string& value);
  inline void set_end_traffic_no(const char* value);
  inline void set_end_traffic_no(const char* value, size_t size);
  inline ::std::string* mutable_end_traffic_no();
  inline ::std::string* release_end_traffic_no();
  inline void set_allocated_end_traffic_no(::std::string* end_traffic_no);

  // required .IM.Buddy.Route route = 6;
  inline bool has_route() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 6;
  inline const ::IM::Buddy::Route& route() const;
  inline ::IM::Buddy::Route* mutable_route();
  inline ::IM::Buddy::Route* release_route();
  inline void set_allocated_route(::IM::Buddy::Route* route);

  // @@protoc_insertion_point(class_scope:IM.Buddy.CollectionRoute)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_start_traffic_no();
  inline void clear_has_start_traffic_no();
  inline void set_has_end_traffic_no();
  inline void clear_has_end_traffic_no();
  inline void set_has_route();
  inline void clear_has_route();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_date_;
  ::std::string* end_date_;
  ::std::string* start_traffic_no_;
  ::std::string* end_traffic_no_;
  ::IM::Buddy::Route* route_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static CollectionRoute* default_instance_;
};
// -------------------------------------------------------------------

class NewQueryRadomRouteReq : public ::google::protobuf::MessageLite {
 public:
  NewQueryRadomRouteReq();
  virtual ~NewQueryRadomRouteReq();

  NewQueryRadomRouteReq(const NewQueryRadomRouteReq& from);

  inline NewQueryRadomRouteReq& operator=(const NewQueryRadomRouteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewQueryRadomRouteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewQueryRadomRouteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewQueryRadomRouteReq* other);

  // implements Message ----------------------------------------------

  NewQueryRadomRouteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewQueryRadomRouteReq& from);
  void MergeFrom(const NewQueryRadomRouteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated string tags = 2;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 2;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // required string sentence = 3;
  inline bool has_sentence() const;
  inline void clear_sentence();
  static const int kSentenceFieldNumber = 3;
  inline const ::std::string& sentence() const;
  inline void set_sentence(const ::std::string& value);
  inline void set_sentence(const char* value);
  inline void set_sentence(const char* value, size_t size);
  inline ::std::string* mutable_sentence();
  inline ::std::string* release_sentence();
  inline void set_allocated_sentence(::std::string* sentence);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewQueryRadomRouteReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_sentence();
  inline void clear_has_sentence();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::std::string* sentence_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewQueryRadomRouteReq* default_instance_;
};
// -------------------------------------------------------------------

class NewQueryRadomRouteRsp : public ::google::protobuf::MessageLite {
 public:
  NewQueryRadomRouteRsp();
  virtual ~NewQueryRadomRouteRsp();

  NewQueryRadomRouteRsp(const NewQueryRadomRouteRsp& from);

  inline NewQueryRadomRouteRsp& operator=(const NewQueryRadomRouteRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewQueryRadomRouteRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewQueryRadomRouteRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewQueryRadomRouteRsp* other);

  // implements Message ----------------------------------------------

  NewQueryRadomRouteRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewQueryRadomRouteRsp& from);
  void MergeFrom(const NewQueryRadomRouteRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.Route routes = 3;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 3;
  inline const ::IM::Buddy::Route& routes(int index) const;
  inline ::IM::Buddy::Route* mutable_routes(int index);
  inline ::IM::Buddy::Route* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::Route >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::Route >*
      mutable_routes();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewQueryRadomRouteRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::Route > routes_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewQueryRadomRouteRsp* default_instance_;
};
// -------------------------------------------------------------------

class NewUpdateRadomRouteReq : public ::google::protobuf::MessageLite {
 public:
  NewUpdateRadomRouteReq();
  virtual ~NewUpdateRadomRouteReq();

  NewUpdateRadomRouteReq(const NewUpdateRadomRouteReq& from);

  inline NewUpdateRadomRouteReq& operator=(const NewUpdateRadomRouteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewUpdateRadomRouteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewUpdateRadomRouteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewUpdateRadomRouteReq* other);

  // implements Message ----------------------------------------------

  NewUpdateRadomRouteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewUpdateRadomRouteReq& from);
  void MergeFrom(const NewUpdateRadomRouteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 day_count = 2;
  inline bool has_day_count() const;
  inline void clear_day_count();
  static const int kDayCountFieldNumber = 2;
  inline ::google::protobuf::uint32 day_count() const;
  inline void set_day_count(::google::protobuf::uint32 value);

  // required string city_code = 3;
  inline bool has_city_code() const;
  inline void clear_city_code();
  static const int kCityCodeFieldNumber = 3;
  inline const ::std::string& city_code() const;
  inline void set_city_code(const ::std::string& value);
  inline void set_city_code(const char* value);
  inline void set_city_code(const char* value, size_t size);
  inline ::std::string* mutable_city_code();
  inline ::std::string* release_city_code();
  inline void set_allocated_city_code(::std::string* city_code);

  // required .IM.Buddy.TransportToolType start_transport_tool = 4;
  inline bool has_start_transport_tool() const;
  inline void clear_start_transport_tool();
  static const int kStartTransportToolFieldNumber = 4;
  inline ::IM::Buddy::TransportToolType start_transport_tool() const;
  inline void set_start_transport_tool(::IM::Buddy::TransportToolType value);

  // required .IM.Buddy.TransportToolType end_transport_tool = 5;
  inline bool has_end_transport_tool() const;
  inline void clear_end_transport_tool();
  static const int kEndTransportToolFieldNumber = 5;
  inline ::IM::Buddy::TransportToolType end_transport_tool() const;
  inline void set_end_transport_tool(::IM::Buddy::TransportToolType value);

  // required string start_time = 6;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 6;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  inline void set_allocated_start_time(::std::string* start_time);

  // required string end_time = 7;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 7;
  inline const ::std::string& end_time() const;
  inline void set_end_time(const ::std::string& value);
  inline void set_end_time(const char* value);
  inline void set_end_time(const char* value, size_t size);
  inline ::std::string* mutable_end_time();
  inline ::std::string* release_end_time();
  inline void set_allocated_end_time(::std::string* end_time);

  // repeated uint32 scenic_ids = 8;
  inline int scenic_ids_size() const;
  inline void clear_scenic_ids();
  static const int kScenicIdsFieldNumber = 8;
  inline ::google::protobuf::uint32 scenic_ids(int index) const;
  inline void set_scenic_ids(int index, ::google::protobuf::uint32 value);
  inline void add_scenic_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      scenic_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_scenic_ids();

  // required string tag = 9;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 9;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewUpdateRadomRouteReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_day_count();
  inline void clear_has_day_count();
  inline void set_has_city_code();
  inline void clear_has_city_code();
  inline void set_has_start_transport_tool();
  inline void clear_has_start_transport_tool();
  inline void set_has_end_transport_tool();
  inline void clear_has_end_transport_tool();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 day_count_;
  ::std::string* city_code_;
  int start_transport_tool_;
  int end_transport_tool_;
  ::std::string* start_time_;
  ::std::string* end_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > scenic_ids_;
  ::std::string* tag_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewUpdateRadomRouteReq* default_instance_;
};
// -------------------------------------------------------------------

class NewUpdateRadomRouteRsp : public ::google::protobuf::MessageLite {
 public:
  NewUpdateRadomRouteRsp();
  virtual ~NewUpdateRadomRouteRsp();

  NewUpdateRadomRouteRsp(const NewUpdateRadomRouteRsp& from);

  inline NewUpdateRadomRouteRsp& operator=(const NewUpdateRadomRouteRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewUpdateRadomRouteRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewUpdateRadomRouteRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewUpdateRadomRouteRsp* other);

  // implements Message ----------------------------------------------

  NewUpdateRadomRouteRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewUpdateRadomRouteRsp& from);
  void MergeFrom(const NewUpdateRadomRouteRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required .IM.Buddy.Route route = 3;
  inline bool has_route() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 3;
  inline const ::IM::Buddy::Route& route() const;
  inline ::IM::Buddy::Route* mutable_route();
  inline ::IM::Buddy::Route* release_route();
  inline void set_allocated_route(::IM::Buddy::Route* route);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewUpdateRadomRouteRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_route();
  inline void clear_has_route();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::IM::Buddy::Route* route_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewUpdateRadomRouteRsp* default_instance_;
};
// -------------------------------------------------------------------

class NewCreateMyTravelReq : public ::google::protobuf::MessageLite {
 public:
  NewCreateMyTravelReq();
  virtual ~NewCreateMyTravelReq();

  NewCreateMyTravelReq(const NewCreateMyTravelReq& from);

  inline NewCreateMyTravelReq& operator=(const NewCreateMyTravelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewCreateMyTravelReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewCreateMyTravelReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewCreateMyTravelReq* other);

  // implements Message ----------------------------------------------

  NewCreateMyTravelReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewCreateMyTravelReq& from);
  void MergeFrom(const NewCreateMyTravelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 day_count = 2;
  inline bool has_day_count() const;
  inline void clear_day_count();
  static const int kDayCountFieldNumber = 2;
  inline ::google::protobuf::uint32 day_count() const;
  inline void set_day_count(::google::protobuf::uint32 value);

  // required string city_code = 3;
  inline bool has_city_code() const;
  inline void clear_city_code();
  static const int kCityCodeFieldNumber = 3;
  inline const ::std::string& city_code() const;
  inline void set_city_code(const ::std::string& value);
  inline void set_city_code(const char* value);
  inline void set_city_code(const char* value, size_t size);
  inline ::std::string* mutable_city_code();
  inline ::std::string* release_city_code();
  inline void set_allocated_city_code(::std::string* city_code);

  // repeated string tags = 4;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 4;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewCreateMyTravelReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_day_count();
  inline void clear_has_day_count();
  inline void set_has_city_code();
  inline void clear_has_city_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 day_count_;
  ::std::string* city_code_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewCreateMyTravelReq* default_instance_;
};
// -------------------------------------------------------------------

class NewCreateMyTravelRsp : public ::google::protobuf::MessageLite {
 public:
  NewCreateMyTravelRsp();
  virtual ~NewCreateMyTravelRsp();

  NewCreateMyTravelRsp(const NewCreateMyTravelRsp& from);

  inline NewCreateMyTravelRsp& operator=(const NewCreateMyTravelRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewCreateMyTravelRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewCreateMyTravelRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewCreateMyTravelRsp* other);

  // implements Message ----------------------------------------------

  NewCreateMyTravelRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewCreateMyTravelRsp& from);
  void MergeFrom(const NewCreateMyTravelRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required .IM.Buddy.Route route = 3;
  inline bool has_route() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 3;
  inline const ::IM::Buddy::Route& route() const;
  inline ::IM::Buddy::Route* mutable_route();
  inline ::IM::Buddy::Route* release_route();
  inline void set_allocated_route(::IM::Buddy::Route* route);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewCreateMyTravelRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_route();
  inline void clear_has_route();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::IM::Buddy::Route* route_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewCreateMyTravelRsp* default_instance_;
};
// -------------------------------------------------------------------

class NewCreateCollectRouteReq : public ::google::protobuf::MessageLite {
 public:
  NewCreateCollectRouteReq();
  virtual ~NewCreateCollectRouteReq();

  NewCreateCollectRouteReq(const NewCreateCollectRouteReq& from);

  inline NewCreateCollectRouteReq& operator=(const NewCreateCollectRouteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewCreateCollectRouteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewCreateCollectRouteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewCreateCollectRouteReq* other);

  // implements Message ----------------------------------------------

  NewCreateCollectRouteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewCreateCollectRouteReq& from);
  void MergeFrom(const NewCreateCollectRouteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.Buddy.CollectionRoute collect = 2;
  inline bool has_collect() const;
  inline void clear_collect();
  static const int kCollectFieldNumber = 2;
  inline const ::IM::Buddy::CollectionRoute& collect() const;
  inline ::IM::Buddy::CollectionRoute* mutable_collect();
  inline ::IM::Buddy::CollectionRoute* release_collect();
  inline void set_allocated_collect(::IM::Buddy::CollectionRoute* collect);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewCreateCollectRouteReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_collect();
  inline void clear_has_collect();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Buddy::CollectionRoute* collect_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewCreateCollectRouteReq* default_instance_;
};
// -------------------------------------------------------------------

class NewCreateCollectRouteRsp : public ::google::protobuf::MessageLite {
 public:
  NewCreateCollectRouteRsp();
  virtual ~NewCreateCollectRouteRsp();

  NewCreateCollectRouteRsp(const NewCreateCollectRouteRsp& from);

  inline NewCreateCollectRouteRsp& operator=(const NewCreateCollectRouteRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewCreateCollectRouteRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewCreateCollectRouteRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewCreateCollectRouteRsp* other);

  // implements Message ----------------------------------------------

  NewCreateCollectRouteRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewCreateCollectRouteRsp& from);
  void MergeFrom(const NewCreateCollectRouteRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required uint32 collect_id = 3;
  inline bool has_collect_id() const;
  inline void clear_collect_id();
  static const int kCollectIdFieldNumber = 3;
  inline ::google::protobuf::uint32 collect_id() const;
  inline void set_collect_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewCreateCollectRouteRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_collect_id();
  inline void clear_has_collect_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 collect_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewCreateCollectRouteRsp* default_instance_;
};
// -------------------------------------------------------------------

class NewDelCollectRouteReq : public ::google::protobuf::MessageLite {
 public:
  NewDelCollectRouteReq();
  virtual ~NewDelCollectRouteReq();

  NewDelCollectRouteReq(const NewDelCollectRouteReq& from);

  inline NewDelCollectRouteReq& operator=(const NewDelCollectRouteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewDelCollectRouteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewDelCollectRouteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewDelCollectRouteReq* other);

  // implements Message ----------------------------------------------

  NewDelCollectRouteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewDelCollectRouteReq& from);
  void MergeFrom(const NewDelCollectRouteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 collect_id = 2;
  inline int collect_id_size() const;
  inline void clear_collect_id();
  static const int kCollectIdFieldNumber = 2;
  inline ::google::protobuf::uint32 collect_id(int index) const;
  inline void set_collect_id(int index, ::google::protobuf::uint32 value);
  inline void add_collect_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      collect_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_collect_id();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewDelCollectRouteReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > collect_id_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewDelCollectRouteReq* default_instance_;
};
// -------------------------------------------------------------------

class NewDelCollectRouteRsp : public ::google::protobuf::MessageLite {
 public:
  NewDelCollectRouteRsp();
  virtual ~NewDelCollectRouteRsp();

  NewDelCollectRouteRsp(const NewDelCollectRouteRsp& from);

  inline NewDelCollectRouteRsp& operator=(const NewDelCollectRouteRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewDelCollectRouteRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewDelCollectRouteRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewDelCollectRouteRsp* other);

  // implements Message ----------------------------------------------

  NewDelCollectRouteRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewDelCollectRouteRsp& from);
  void MergeFrom(const NewDelCollectRouteRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewDelCollectRouteRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewDelCollectRouteRsp* default_instance_;
};
// -------------------------------------------------------------------

class NewQueryCollectRouteReq : public ::google::protobuf::MessageLite {
 public:
  NewQueryCollectRouteReq();
  virtual ~NewQueryCollectRouteReq();

  NewQueryCollectRouteReq(const NewQueryCollectRouteReq& from);

  inline NewQueryCollectRouteReq& operator=(const NewQueryCollectRouteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewQueryCollectRouteReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewQueryCollectRouteReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewQueryCollectRouteReq* other);

  // implements Message ----------------------------------------------

  NewQueryCollectRouteReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewQueryCollectRouteReq& from);
  void MergeFrom(const NewQueryCollectRouteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewQueryCollectRouteReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewQueryCollectRouteReq* default_instance_;
};
// -------------------------------------------------------------------

class NewQueryCollectRouteRsp : public ::google::protobuf::MessageLite {
 public:
  NewQueryCollectRouteRsp();
  virtual ~NewQueryCollectRouteRsp();

  NewQueryCollectRouteRsp(const NewQueryCollectRouteRsp& from);

  inline NewQueryCollectRouteRsp& operator=(const NewQueryCollectRouteRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewQueryCollectRouteRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewQueryCollectRouteRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewQueryCollectRouteRsp* other);

  // implements Message ----------------------------------------------

  NewQueryCollectRouteRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewQueryCollectRouteRsp& from);
  void MergeFrom(const NewQueryCollectRouteRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.CollectionRoute collections = 3;
  inline int collections_size() const;
  inline void clear_collections();
  static const int kCollectionsFieldNumber = 3;
  inline const ::IM::Buddy::CollectionRoute& collections(int index) const;
  inline ::IM::Buddy::CollectionRoute* mutable_collections(int index);
  inline ::IM::Buddy::CollectionRoute* add_collections();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::CollectionRoute >&
      collections() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::CollectionRoute >*
      mutable_collections();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.NewQueryCollectRouteRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::CollectionRoute > collections_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static NewQueryCollectRouteRsp* default_instance_;
};
// -------------------------------------------------------------------

class Info_Modify_Req : public ::google::protobuf::MessageLite {
 public:
  Info_Modify_Req();
  virtual ~Info_Modify_Req();

  Info_Modify_Req(const Info_Modify_Req& from);

  inline Info_Modify_Req& operator=(const Info_Modify_Req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Info_Modify_Req& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Info_Modify_Req* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Info_Modify_Req* other);

  // implements Message ----------------------------------------------

  Info_Modify_Req* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Info_Modify_Req& from);
  void MergeFrom(const Info_Modify_Req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.Buddy.ModifyType modify_type = 2;
  inline bool has_modify_type() const;
  inline void clear_modify_type();
  static const int kModifyTypeFieldNumber = 2;
  inline ::IM::Buddy::ModifyType modify_type() const;
  inline void set_modify_type(::IM::Buddy::ModifyType value);

  // required string modify_context = 3;
  inline bool has_modify_context() const;
  inline void clear_modify_context();
  static const int kModifyContextFieldNumber = 3;
  inline const ::std::string& modify_context() const;
  inline void set_modify_context(const ::std::string& value);
  inline void set_modify_context(const char* value);
  inline void set_modify_context(const char* value, size_t size);
  inline ::std::string* mutable_modify_context();
  inline ::std::string* release_modify_context();
  inline void set_allocated_modify_context(::std::string* modify_context);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.Info_Modify_Req)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_modify_type();
  inline void clear_has_modify_type();
  inline void set_has_modify_context();
  inline void clear_has_modify_context();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int modify_type_;
  ::std::string* modify_context_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static Info_Modify_Req* default_instance_;
};
// -------------------------------------------------------------------

class Info_Modify_Rsp : public ::google::protobuf::MessageLite {
 public:
  Info_Modify_Rsp();
  virtual ~Info_Modify_Rsp();

  Info_Modify_Rsp(const Info_Modify_Rsp& from);

  inline Info_Modify_Rsp& operator=(const Info_Modify_Rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Info_Modify_Rsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Info_Modify_Rsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Info_Modify_Rsp* other);

  // implements Message ----------------------------------------------

  Info_Modify_Rsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Info_Modify_Rsp& from);
  void MergeFrom(const Info_Modify_Rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.ResultType ret_code = 2;
  inline bool has_ret_code() const;
  inline void clear_ret_code();
  static const int kRetCodeFieldNumber = 2;
  inline ::IM::BaseDefine::ResultType ret_code() const;
  inline void set_ret_code(::IM::BaseDefine::ResultType value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.Info_Modify_Rsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_ret_code();
  inline void clear_has_ret_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int ret_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static Info_Modify_Rsp* default_instance_;
};
// ===================================================================


// ===================================================================

// IMRecentContactSessionReq

// required uint32 user_id = 1;
inline bool IMRecentContactSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.user_id)
  return user_id_;
}
inline void IMRecentContactSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMRecentContactSessionReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRecentContactSessionReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRecentContactSessionReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRecentContactSessionReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
  return latest_update_time_;
}
inline void IMRecentContactSessionReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline ::std::string* IMRecentContactSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRecentContactSessionRsp

// required uint32 user_id = 1;
inline bool IMRecentContactSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.user_id)
  return user_id_;
}
inline void IMRecentContactSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.user_id)
}

// repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
inline int IMRecentContactSessionRsp::contact_session_list_size() const {
  return contact_session_list_.size();
}
inline void IMRecentContactSessionRsp::clear_contact_session_list() {
  contact_session_list_.Clear();
}
inline const ::IM::BaseDefine::ContactSessionInfo& IMRecentContactSessionRsp::contact_session_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Get(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::mutable_contact_session_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Mutable(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::add_contact_session_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
IMRecentContactSessionRsp::contact_session_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
IMRecentContactSessionRsp::mutable_contact_session_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return &contact_session_list_;
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline ::std::string* IMRecentContactSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserStatNotify

// required .IM.BaseDefine.UserStat user_stat = 1;
inline bool IMUserStatNotify::has_user_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserStatNotify::set_has_user_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserStatNotify::clear_has_user_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserStatNotify::clear_user_stat() {
  if (user_stat_ != NULL) user_stat_->::IM::BaseDefine::UserStat::Clear();
  clear_has_user_stat();
}
inline const ::IM::BaseDefine::UserStat& IMUserStatNotify::user_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserStatNotify.user_stat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_stat_ != NULL ? *user_stat_ : *default_instance().user_stat_;
#else
  return user_stat_ != NULL ? *user_stat_ : *default_instance_->user_stat_;
#endif
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::mutable_user_stat() {
  set_has_user_stat();
  if (user_stat_ == NULL) user_stat_ = new ::IM::BaseDefine::UserStat;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserStatNotify.user_stat)
  return user_stat_;
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::release_user_stat() {
  clear_has_user_stat();
  ::IM::BaseDefine::UserStat* temp = user_stat_;
  user_stat_ = NULL;
  return temp;
}
inline void IMUserStatNotify::set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat) {
  delete user_stat_;
  user_stat_ = user_stat;
  if (user_stat) {
    set_has_user_stat();
  } else {
    clear_has_user_stat();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserStatNotify.user_stat)
}

// -------------------------------------------------------------------

// IMUsersInfoReq

// required uint32 user_id = 1;
inline bool IMUsersInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id)
  return user_id_;
}
inline void IMUsersInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersInfoReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersInfoReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersInfoReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline void IMUsersInfoReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersInfoReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersInfoReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline ::std::string* IMUsersInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersInfoRsp

// required uint32 user_id = 1;
inline bool IMUsersInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_id)
  return user_id_;
}
inline void IMUsersInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.user_id)
}

// repeated .IM.BaseDefine.UserInfo user_info_list = 2;
inline int IMUsersInfoRsp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void IMUsersInfoRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMUsersInfoRsp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::add_user_info_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMUsersInfoRsp::user_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMUsersInfoRsp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return &user_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline ::std::string* IMUsersInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionReq

// required uint32 user_id = 1;
inline bool IMRemoveSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.user_id)
  return user_id_;
}
inline void IMRemoveSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionReq::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionReq::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionReq::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionReq::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionReq::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionReq::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_id)
  return session_id_;
}
inline void IMRemoveSessionReq::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline ::std::string* IMRemoveSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionRsp

// required uint32 user_id = 1;
inline bool IMRemoveSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.user_id)
  return user_id_;
}
inline void IMRemoveSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMRemoveSessionRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.result_code)
  return result_code_;
}
inline void IMRemoveSessionRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.result_code)
}

// required .IM.BaseDefine.SessionType session_type = 3;
inline bool IMRemoveSessionRsp::has_session_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionRsp::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionRsp::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionRsp::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionRsp::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_type)
}

// required uint32 session_id = 4;
inline bool IMRemoveSessionRsp::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionRsp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionRsp::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_id)
  return session_id_;
}
inline void IMRemoveSessionRsp::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRemoveSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRemoveSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRemoveSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline ::std::string* IMRemoveSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserReq

// required uint32 user_id = 1;
inline bool IMAllUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.user_id)
  return user_id_;
}
inline void IMAllUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMAllUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAllUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAllUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAllUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.attach_data)
  return *attach_data_;
}
inline void IMAllUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserReq.attach_data)
}
inline ::std::string* IMAllUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserReq.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserRsp

// required uint32 user_id = 1;
inline bool IMAllUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_id)
  return user_id_;
}
inline void IMAllUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.latest_update_time)
}

// repeated .IM.BaseDefine.UserInfo user_list = 3;
inline int IMAllUserRsp::user_list_size() const {
  return user_list_.size();
}
inline void IMAllUserRsp::clear_user_list() {
  user_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMAllUserRsp::user_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::add_user_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMAllUserRsp::user_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMAllUserRsp::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMAllUserRsp.user_list)
  return &user_list_;
}

// optional bytes attach_data = 20;
inline bool IMAllUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAllUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAllUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAllUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.attach_data)
  return *attach_data_;
}
inline void IMAllUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserRsp.attach_data)
}
inline ::std::string* IMAllUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatReq

// required uint32 user_id = 1;
inline bool IMUsersStatReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id)
  return user_id_;
}
inline void IMUsersStatReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersStatReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersStatReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersStatReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline void IMUsersStatReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersStatReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersStatReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.attach_data)
  return *attach_data_;
}
inline void IMUsersStatReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatReq.attach_data)
}
inline ::std::string* IMUsersStatReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatRsp

// required uint32 user_id = 1;
inline bool IMUsersStatRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_id)
  return user_id_;
}
inline void IMUsersStatRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.user_id)
}

// repeated .IM.BaseDefine.UserStat user_stat_list = 2;
inline int IMUsersStatRsp::user_stat_list_size() const {
  return user_stat_list_.size();
}
inline void IMUsersStatRsp::clear_user_stat_list() {
  user_stat_list_.Clear();
}
inline const ::IM::BaseDefine::UserStat& IMUsersStatRsp::user_stat_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Get(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::mutable_user_stat_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::add_user_stat_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
IMUsersStatRsp::user_stat_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
IMUsersStatRsp::mutable_user_stat_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return &user_stat_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersStatRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline ::std::string* IMUsersStatRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatRsp.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarReq

// required uint32 user_id = 1;
inline bool IMChangeAvatarReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.user_id)
  return user_id_;
}
inline void IMChangeAvatarReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.user_id)
}

// required string avatar_url = 2;
inline bool IMChangeAvatarReq::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarReq::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarReq::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarReq::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMChangeAvatarReq::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return *avatar_url_;
}
inline void IMChangeAvatarReq::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline ::std::string* IMChangeAvatarReq::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMChangeAvatarReq::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.avatar_url)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline ::std::string* IMChangeAvatarReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarRsp

// required uint32 user_id = 1;
inline bool IMChangeAvatarRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.user_id)
  return user_id_;
}
inline void IMChangeAvatarRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeAvatarRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.result_code)
  return result_code_;
}
inline void IMChangeAvatarRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline ::std::string* IMChangeAvatarRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarRsp.attach_data)
}

// -------------------------------------------------------------------

// IMPCLoginStatusNotify

// required uint32 user_id = 1;
inline bool IMPCLoginStatusNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMPCLoginStatusNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.user_id)
  return user_id_;
}
inline void IMPCLoginStatusNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.user_id)
}

// required .IM.BaseDefine.UserStatType login_stat = 2;
inline bool IMPCLoginStatusNotify::has_login_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_login_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_has_login_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_login_stat() {
  login_stat_ = 1;
  clear_has_login_stat();
}
inline ::IM::BaseDefine::UserStatType IMPCLoginStatusNotify::login_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.login_stat)
  return static_cast< ::IM::BaseDefine::UserStatType >(login_stat_);
}
inline void IMPCLoginStatusNotify::set_login_stat(::IM::BaseDefine::UserStatType value) {
  assert(::IM::BaseDefine::UserStatType_IsValid(value));
  set_has_login_stat();
  login_stat_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.login_stat)
}

// -------------------------------------------------------------------

// IMRemoveSessionNotify

// required uint32 user_id = 1;
inline bool IMRemoveSessionNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.user_id)
  return user_id_;
}
inline void IMRemoveSessionNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionNotify::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionNotify::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionNotify::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionNotify::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionNotify::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionNotify::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionNotify::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionNotify::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_id)
  return session_id_;
}
inline void IMRemoveSessionNotify::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_id)
}

// -------------------------------------------------------------------

// IMDepartmentReq

// required uint32 user_id = 1;
inline bool IMDepartmentReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.user_id)
  return user_id_;
}
inline void IMDepartmentReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMDepartmentReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDepartmentReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDepartmentReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDepartmentReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.attach_data)
  return *attach_data_;
}
inline void IMDepartmentReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentReq.attach_data)
}
inline ::std::string* IMDepartmentReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentReq.attach_data)
}

// -------------------------------------------------------------------

// IMDepartmentRsp

// required uint32 user_id = 1;
inline bool IMDepartmentRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.user_id)
  return user_id_;
}
inline void IMDepartmentRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.latest_update_time)
}

// repeated .IM.BaseDefine.DepartInfo dept_list = 3;
inline int IMDepartmentRsp::dept_list_size() const {
  return dept_list_.size();
}
inline void IMDepartmentRsp::clear_dept_list() {
  dept_list_.Clear();
}
inline const ::IM::BaseDefine::DepartInfo& IMDepartmentRsp::dept_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Get(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::mutable_dept_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Mutable(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::add_dept_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
IMDepartmentRsp::dept_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
IMDepartmentRsp::mutable_dept_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return &dept_list_;
}

// optional bytes attach_data = 20;
inline bool IMDepartmentRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDepartmentRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDepartmentRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDepartmentRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.attach_data)
  return *attach_data_;
}
inline void IMDepartmentRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline ::std::string* IMDepartmentRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAvatarChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMAvatarChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAvatarChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAvatarChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAvatarChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMAvatarChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMAvatarChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
}

// required string avatar_url = 2;
inline bool IMAvatarChangedNotify::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAvatarChangedNotify::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAvatarChangedNotify::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAvatarChangedNotify::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMAvatarChangedNotify::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return *avatar_url_;
}
inline void IMAvatarChangedNotify::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline ::std::string* IMAvatarChangedNotify::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMAvatarChangedNotify::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAvatarChangedNotify::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}

// -------------------------------------------------------------------

// IMChangeSignInfoReq

// required uint32 user_id = 1;
inline bool IMChangeSignInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.user_id)
  return user_id_;
}
inline void IMChangeSignInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.user_id)
}

// required string sign_info = 2;
inline bool IMChangeSignInfoReq::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoReq::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoReq::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoReq::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoReq::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoReq::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline ::std::string* IMChangeSignInfoReq::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoReq::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline ::std::string* IMChangeSignInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeSignInfoRsp

// required uint32 user_id = 1;
inline bool IMChangeSignInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.user_id)
  return user_id_;
}
inline void IMChangeSignInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeSignInfoRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.result_code)
  return result_code_;
}
inline void IMChangeSignInfoRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.result_code)
}

// optional string sign_info = 3;
inline bool IMChangeSignInfoRsp::has_sign_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_sign_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoRsp::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoRsp::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoRsp::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMSignInfoChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMSignInfoChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMSignInfoChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMSignInfoChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
}

// required string sign_info = 2;
inline bool IMSignInfoChangedNotify::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMSignInfoChangedNotify::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return *sign_info_;
}
inline void IMSignInfoChangedNotify::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline ::std::string* IMSignInfoChangedNotify::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return sign_info_;
}
inline ::std::string* IMSignInfoChangedNotify::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSignInfoChangedNotify::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}

// -------------------------------------------------------------------

// TravelToolInfo

// required uint32 id = 1;
inline bool TravelToolInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TravelToolInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TravelToolInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TravelToolInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 TravelToolInfo::id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.id)
  return id_;
}
inline void TravelToolInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.id)
}

// required uint32 transport_tool_type = 2;
inline bool TravelToolInfo::has_transport_tool_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TravelToolInfo::set_has_transport_tool_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TravelToolInfo::clear_has_transport_tool_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TravelToolInfo::clear_transport_tool_type() {
  transport_tool_type_ = 0u;
  clear_has_transport_tool_type();
}
inline ::google::protobuf::uint32 TravelToolInfo::transport_tool_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.transport_tool_type)
  return transport_tool_type_;
}
inline void TravelToolInfo::set_transport_tool_type(::google::protobuf::uint32 value) {
  set_has_transport_tool_type();
  transport_tool_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.transport_tool_type)
}

// required string no = 3;
inline bool TravelToolInfo::has_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TravelToolInfo::set_has_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TravelToolInfo::clear_has_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TravelToolInfo::clear_no() {
  if (no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_->clear();
  }
  clear_has_no();
}
inline const ::std::string& TravelToolInfo::no() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.no)
  return *no_;
}
inline void TravelToolInfo::set_no(const ::std::string& value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  no_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.no)
}
inline void TravelToolInfo::set_no(const char* value) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  no_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.no)
}
inline void TravelToolInfo::set_no(const char* value, size_t size) {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.no)
}
inline ::std::string* TravelToolInfo::mutable_no() {
  set_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.no)
  return no_;
}
inline ::std::string* TravelToolInfo::release_no() {
  clear_has_no();
  if (no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = no_;
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_no(::std::string* no) {
  if (no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete no_;
  }
  if (no) {
    set_has_no();
    no_ = no;
  } else {
    clear_has_no();
    no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.no)
}

// required string place_from_code = 4;
inline bool TravelToolInfo::has_place_from_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TravelToolInfo::set_has_place_from_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TravelToolInfo::clear_has_place_from_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TravelToolInfo::clear_place_from_code() {
  if (place_from_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_->clear();
  }
  clear_has_place_from_code();
}
inline const ::std::string& TravelToolInfo::place_from_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_from_code)
  return *place_from_code_;
}
inline void TravelToolInfo::set_place_from_code(const ::std::string& value) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_from_code)
}
inline void TravelToolInfo::set_place_from_code(const char* value) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_from_code)
}
inline void TravelToolInfo::set_place_from_code(const char* value, size_t size) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_from_code)
}
inline ::std::string* TravelToolInfo::mutable_place_from_code() {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_from_code)
  return place_from_code_;
}
inline ::std::string* TravelToolInfo::release_place_from_code() {
  clear_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_from_code_;
    place_from_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_from_code(::std::string* place_from_code) {
  if (place_from_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_from_code_;
  }
  if (place_from_code) {
    set_has_place_from_code();
    place_from_code_ = place_from_code;
  } else {
    clear_has_place_from_code();
    place_from_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_from_code)
}

// required string place_from = 5;
inline bool TravelToolInfo::has_place_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TravelToolInfo::set_has_place_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TravelToolInfo::clear_has_place_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TravelToolInfo::clear_place_from() {
  if (place_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_->clear();
  }
  clear_has_place_from();
}
inline const ::std::string& TravelToolInfo::place_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_from)
  return *place_from_;
}
inline void TravelToolInfo::set_place_from(const ::std::string& value) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_from)
}
inline void TravelToolInfo::set_place_from(const char* value) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_from)
}
inline void TravelToolInfo::set_place_from(const char* value, size_t size) {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  place_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_from)
}
inline ::std::string* TravelToolInfo::mutable_place_from() {
  set_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_from)
  return place_from_;
}
inline ::std::string* TravelToolInfo::release_place_from() {
  clear_has_place_from();
  if (place_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_from_;
    place_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_from(::std::string* place_from) {
  if (place_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_from_;
  }
  if (place_from) {
    set_has_place_from();
    place_from_ = place_from;
  } else {
    clear_has_place_from();
    place_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_from)
}

// required string place_to_code = 6;
inline bool TravelToolInfo::has_place_to_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TravelToolInfo::set_has_place_to_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TravelToolInfo::clear_has_place_to_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TravelToolInfo::clear_place_to_code() {
  if (place_to_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_->clear();
  }
  clear_has_place_to_code();
}
inline const ::std::string& TravelToolInfo::place_to_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_to_code)
  return *place_to_code_;
}
inline void TravelToolInfo::set_place_to_code(const ::std::string& value) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_to_code)
}
inline void TravelToolInfo::set_place_to_code(const char* value) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_to_code)
}
inline void TravelToolInfo::set_place_to_code(const char* value, size_t size) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_to_code)
}
inline ::std::string* TravelToolInfo::mutable_place_to_code() {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_to_code)
  return place_to_code_;
}
inline ::std::string* TravelToolInfo::release_place_to_code() {
  clear_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_to_code_;
    place_to_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_to_code(::std::string* place_to_code) {
  if (place_to_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_to_code_;
  }
  if (place_to_code) {
    set_has_place_to_code();
    place_to_code_ = place_to_code;
  } else {
    clear_has_place_to_code();
    place_to_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_to_code)
}

// required string place_to = 7;
inline bool TravelToolInfo::has_place_to() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TravelToolInfo::set_has_place_to() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TravelToolInfo::clear_has_place_to() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TravelToolInfo::clear_place_to() {
  if (place_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_->clear();
  }
  clear_has_place_to();
}
inline const ::std::string& TravelToolInfo::place_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.place_to)
  return *place_to_;
}
inline void TravelToolInfo::set_place_to(const ::std::string& value) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.place_to)
}
inline void TravelToolInfo::set_place_to(const char* value) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.place_to)
}
inline void TravelToolInfo::set_place_to(const char* value, size_t size) {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  place_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.place_to)
}
inline ::std::string* TravelToolInfo::mutable_place_to() {
  set_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.place_to)
  return place_to_;
}
inline ::std::string* TravelToolInfo::release_place_to() {
  clear_has_place_to();
  if (place_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_to_;
    place_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_place_to(::std::string* place_to) {
  if (place_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_to_;
  }
  if (place_to) {
    set_has_place_to();
    place_to_ = place_to;
  } else {
    clear_has_place_to();
    place_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.place_to)
}

// required string time_from = 8;
inline bool TravelToolInfo::has_time_from() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TravelToolInfo::set_has_time_from() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TravelToolInfo::clear_has_time_from() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TravelToolInfo::clear_time_from() {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_->clear();
  }
  clear_has_time_from();
}
inline const ::std::string& TravelToolInfo::time_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.time_from)
  return *time_from_;
}
inline void TravelToolInfo::set_time_from(const ::std::string& value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.time_from)
}
inline void TravelToolInfo::set_time_from(const char* value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.time_from)
}
inline void TravelToolInfo::set_time_from(const char* value, size_t size) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.time_from)
}
inline ::std::string* TravelToolInfo::mutable_time_from() {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.time_from)
  return time_from_;
}
inline ::std::string* TravelToolInfo::release_time_from() {
  clear_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_from_;
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_time_from(::std::string* time_from) {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_from_;
  }
  if (time_from) {
    set_has_time_from();
    time_from_ = time_from;
  } else {
    clear_has_time_from();
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.time_from)
}

// required string time_to = 9;
inline bool TravelToolInfo::has_time_to() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TravelToolInfo::set_has_time_to() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TravelToolInfo::clear_has_time_to() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TravelToolInfo::clear_time_to() {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_->clear();
  }
  clear_has_time_to();
}
inline const ::std::string& TravelToolInfo::time_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.time_to)
  return *time_to_;
}
inline void TravelToolInfo::set_time_to(const ::std::string& value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.time_to)
}
inline void TravelToolInfo::set_time_to(const char* value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.time_to)
}
inline void TravelToolInfo::set_time_to(const char* value, size_t size) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.time_to)
}
inline ::std::string* TravelToolInfo::mutable_time_to() {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.time_to)
  return time_to_;
}
inline ::std::string* TravelToolInfo::release_time_to() {
  clear_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_to_;
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_time_to(::std::string* time_to) {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_to_;
  }
  if (time_to) {
    set_has_time_to();
    time_to_ = time_to;
  } else {
    clear_has_time_to();
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.time_to)
}

// required string class = 10;
inline bool TravelToolInfo::has_class_() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TravelToolInfo::set_has_class_() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TravelToolInfo::clear_has_class_() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TravelToolInfo::clear_class_() {
  if (class__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    class__->clear();
  }
  clear_has_class_();
}
inline const ::std::string& TravelToolInfo::class_() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.class)
  return *class__;
}
inline void TravelToolInfo::set_class_(const ::std::string& value) {
  set_has_class_();
  if (class__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    class__ = new ::std::string;
  }
  class__->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.class)
}
inline void TravelToolInfo::set_class_(const char* value) {
  set_has_class_();
  if (class__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    class__ = new ::std::string;
  }
  class__->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TravelToolInfo.class)
}
inline void TravelToolInfo::set_class_(const char* value, size_t size) {
  set_has_class_();
  if (class__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    class__ = new ::std::string;
  }
  class__->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TravelToolInfo.class)
}
inline ::std::string* TravelToolInfo::mutable_class_() {
  set_has_class_();
  if (class__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    class__ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelToolInfo.class)
  return class__;
}
inline ::std::string* TravelToolInfo::release_class_() {
  clear_has_class_();
  if (class__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = class__;
    class__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TravelToolInfo::set_allocated_class_(::std::string* class_) {
  if (class__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete class__;
  }
  if (class_) {
    set_has_class_();
    class__ = class_;
  } else {
    clear_has_class_();
    class__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelToolInfo.class)
}

// required uint32 price = 11;
inline bool TravelToolInfo::has_price() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TravelToolInfo::set_has_price() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TravelToolInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TravelToolInfo::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 TravelToolInfo::price() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelToolInfo.price)
  return price_;
}
inline void TravelToolInfo::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TravelToolInfo.price)
}

// -------------------------------------------------------------------

// BasicInfo

// required string date_from = 1;
inline bool BasicInfo::has_date_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicInfo::set_has_date_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicInfo::clear_has_date_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicInfo::clear_date_from() {
  if (date_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_->clear();
  }
  clear_has_date_from();
}
inline const ::std::string& BasicInfo::date_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.BasicInfo.date_from)
  return *date_from_;
}
inline void BasicInfo::set_date_from(const ::std::string& value) {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  date_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.BasicInfo.date_from)
}
inline void BasicInfo::set_date_from(const char* value) {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  date_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.BasicInfo.date_from)
}
inline void BasicInfo::set_date_from(const char* value, size_t size) {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  date_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.BasicInfo.date_from)
}
inline ::std::string* BasicInfo::mutable_date_from() {
  set_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.BasicInfo.date_from)
  return date_from_;
}
inline ::std::string* BasicInfo::release_date_from() {
  clear_has_date_from();
  if (date_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_from_;
    date_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicInfo::set_allocated_date_from(::std::string* date_from) {
  if (date_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_from_;
  }
  if (date_from) {
    set_has_date_from();
    date_from_ = date_from;
  } else {
    clear_has_date_from();
    date_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.BasicInfo.date_from)
}

// required string date_to = 2;
inline bool BasicInfo::has_date_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicInfo::set_has_date_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicInfo::clear_has_date_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicInfo::clear_date_to() {
  if (date_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_->clear();
  }
  clear_has_date_to();
}
inline const ::std::string& BasicInfo::date_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.BasicInfo.date_to)
  return *date_to_;
}
inline void BasicInfo::set_date_to(const ::std::string& value) {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  date_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.BasicInfo.date_to)
}
inline void BasicInfo::set_date_to(const char* value) {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  date_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.BasicInfo.date_to)
}
inline void BasicInfo::set_date_to(const char* value, size_t size) {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  date_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.BasicInfo.date_to)
}
inline ::std::string* BasicInfo::mutable_date_to() {
  set_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.BasicInfo.date_to)
  return date_to_;
}
inline ::std::string* BasicInfo::release_date_to() {
  clear_has_date_to();
  if (date_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_to_;
    date_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicInfo::set_allocated_date_to(::std::string* date_to) {
  if (date_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_to_;
  }
  if (date_to) {
    set_has_date_to();
    date_to_ = date_to;
  } else {
    clear_has_date_to();
    date_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.BasicInfo.date_to)
}

// required string place_to_code = 3;
inline bool BasicInfo::has_place_to_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicInfo::set_has_place_to_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicInfo::clear_has_place_to_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicInfo::clear_place_to_code() {
  if (place_to_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_->clear();
  }
  clear_has_place_to_code();
}
inline const ::std::string& BasicInfo::place_to_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.BasicInfo.place_to_code)
  return *place_to_code_;
}
inline void BasicInfo::set_place_to_code(const ::std::string& value) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.BasicInfo.place_to_code)
}
inline void BasicInfo::set_place_to_code(const char* value) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.BasicInfo.place_to_code)
}
inline void BasicInfo::set_place_to_code(const char* value, size_t size) {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  place_to_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.BasicInfo.place_to_code)
}
inline ::std::string* BasicInfo::mutable_place_to_code() {
  set_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_to_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.BasicInfo.place_to_code)
  return place_to_code_;
}
inline ::std::string* BasicInfo::release_place_to_code() {
  clear_has_place_to_code();
  if (place_to_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_to_code_;
    place_to_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicInfo::set_allocated_place_to_code(::std::string* place_to_code) {
  if (place_to_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_to_code_;
  }
  if (place_to_code) {
    set_has_place_to_code();
    place_to_code_ = place_to_code;
  } else {
    clear_has_place_to_code();
    place_to_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.BasicInfo.place_to_code)
}

// required uint32 person_num = 4;
inline bool BasicInfo::has_person_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BasicInfo::set_has_person_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BasicInfo::clear_has_person_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BasicInfo::clear_person_num() {
  person_num_ = 0u;
  clear_has_person_num();
}
inline ::google::protobuf::uint32 BasicInfo::person_num() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.BasicInfo.person_num)
  return person_num_;
}
inline void BasicInfo::set_person_num(::google::protobuf::uint32 value) {
  set_has_person_num();
  person_num_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.BasicInfo.person_num)
}

// required string place_from_code = 5;
inline bool BasicInfo::has_place_from_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BasicInfo::set_has_place_from_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BasicInfo::clear_has_place_from_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BasicInfo::clear_place_from_code() {
  if (place_from_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_->clear();
  }
  clear_has_place_from_code();
}
inline const ::std::string& BasicInfo::place_from_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.BasicInfo.place_from_code)
  return *place_from_code_;
}
inline void BasicInfo::set_place_from_code(const ::std::string& value) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.BasicInfo.place_from_code)
}
inline void BasicInfo::set_place_from_code(const char* value) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.BasicInfo.place_from_code)
}
inline void BasicInfo::set_place_from_code(const char* value, size_t size) {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  place_from_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.BasicInfo.place_from_code)
}
inline ::std::string* BasicInfo::mutable_place_from_code() {
  set_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_from_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.BasicInfo.place_from_code)
  return place_from_code_;
}
inline ::std::string* BasicInfo::release_place_from_code() {
  clear_has_place_from_code();
  if (place_from_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_from_code_;
    place_from_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicInfo::set_allocated_place_from_code(::std::string* place_from_code) {
  if (place_from_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_from_code_;
  }
  if (place_from_code) {
    set_has_place_from_code();
    place_from_code_ = place_from_code;
  } else {
    clear_has_place_from_code();
    place_from_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.BasicInfo.place_from_code)
}

// required string place_back_code = 6;
inline bool BasicInfo::has_place_back_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BasicInfo::set_has_place_back_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BasicInfo::clear_has_place_back_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BasicInfo::clear_place_back_code() {
  if (place_back_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_code_->clear();
  }
  clear_has_place_back_code();
}
inline const ::std::string& BasicInfo::place_back_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.BasicInfo.place_back_code)
  return *place_back_code_;
}
inline void BasicInfo::set_place_back_code(const ::std::string& value) {
  set_has_place_back_code();
  if (place_back_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_code_ = new ::std::string;
  }
  place_back_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.BasicInfo.place_back_code)
}
inline void BasicInfo::set_place_back_code(const char* value) {
  set_has_place_back_code();
  if (place_back_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_code_ = new ::std::string;
  }
  place_back_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.BasicInfo.place_back_code)
}
inline void BasicInfo::set_place_back_code(const char* value, size_t size) {
  set_has_place_back_code();
  if (place_back_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_code_ = new ::std::string;
  }
  place_back_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.BasicInfo.place_back_code)
}
inline ::std::string* BasicInfo::mutable_place_back_code() {
  set_has_place_back_code();
  if (place_back_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    place_back_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.BasicInfo.place_back_code)
  return place_back_code_;
}
inline ::std::string* BasicInfo::release_place_back_code() {
  clear_has_place_back_code();
  if (place_back_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = place_back_code_;
    place_back_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BasicInfo::set_allocated_place_back_code(::std::string* place_back_code) {
  if (place_back_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete place_back_code_;
  }
  if (place_back_code) {
    set_has_place_back_code();
    place_back_code_ = place_back_code;
  } else {
    clear_has_place_back_code();
    place_back_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.BasicInfo.place_back_code)
}

// -------------------------------------------------------------------

// TransportConfig

// required uint32 tool_type = 1;
inline bool TransportConfig::has_tool_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportConfig::set_has_tool_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportConfig::clear_has_tool_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportConfig::clear_tool_type() {
  tool_type_ = 0u;
  clear_has_tool_type();
}
inline ::google::protobuf::uint32 TransportConfig::tool_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TransportConfig.tool_type)
  return tool_type_;
}
inline void TransportConfig::set_tool_type(::google::protobuf::uint32 value) {
  set_has_tool_type();
  tool_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TransportConfig.tool_type)
}

// required string time_from = 2;
inline bool TransportConfig::has_time_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportConfig::set_has_time_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportConfig::clear_has_time_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportConfig::clear_time_from() {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_->clear();
  }
  clear_has_time_from();
}
inline const ::std::string& TransportConfig::time_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TransportConfig.time_from)
  return *time_from_;
}
inline void TransportConfig::set_time_from(const ::std::string& value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TransportConfig.time_from)
}
inline void TransportConfig::set_time_from(const char* value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TransportConfig.time_from)
}
inline void TransportConfig::set_time_from(const char* value, size_t size) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TransportConfig.time_from)
}
inline ::std::string* TransportConfig::mutable_time_from() {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TransportConfig.time_from)
  return time_from_;
}
inline ::std::string* TransportConfig::release_time_from() {
  clear_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_from_;
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransportConfig::set_allocated_time_from(::std::string* time_from) {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_from_;
  }
  if (time_from) {
    set_has_time_from();
    time_from_ = time_from;
  } else {
    clear_has_time_from();
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TransportConfig.time_from)
}

// required string time_to = 3;
inline bool TransportConfig::has_time_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportConfig::set_has_time_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportConfig::clear_has_time_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportConfig::clear_time_to() {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_->clear();
  }
  clear_has_time_to();
}
inline const ::std::string& TransportConfig::time_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TransportConfig.time_to)
  return *time_to_;
}
inline void TransportConfig::set_time_to(const ::std::string& value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.TransportConfig.time_to)
}
inline void TransportConfig::set_time_to(const char* value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.TransportConfig.time_to)
}
inline void TransportConfig::set_time_to(const char* value, size_t size) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.TransportConfig.time_to)
}
inline ::std::string* TransportConfig::mutable_time_to() {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TransportConfig.time_to)
  return time_to_;
}
inline ::std::string* TransportConfig::release_time_to() {
  clear_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_to_;
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransportConfig::set_allocated_time_to(::std::string* time_to) {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_to_;
  }
  if (time_to) {
    set_has_time_to();
    time_to_ = time_to;
  } else {
    clear_has_time_to();
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TransportConfig.time_to)
}

// required .IM.Buddy.QualityType quality = 4;
inline bool TransportConfig::has_quality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransportConfig::set_has_quality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransportConfig::clear_has_quality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransportConfig::clear_quality() {
  quality_ = 1;
  clear_has_quality();
}
inline ::IM::Buddy::QualityType TransportConfig::quality() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TransportConfig.quality)
  return static_cast< ::IM::Buddy::QualityType >(quality_);
}
inline void TransportConfig::set_quality(::IM::Buddy::QualityType value) {
  assert(::IM::Buddy::QualityType_IsValid(value));
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TransportConfig.quality)
}

// required uint32 transit = 5;
inline bool TransportConfig::has_transit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransportConfig::set_has_transit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransportConfig::clear_has_transit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransportConfig::clear_transit() {
  transit_ = 0u;
  clear_has_transit();
}
inline ::google::protobuf::uint32 TransportConfig::transit() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TransportConfig.transit)
  return transit_;
}
inline void TransportConfig::set_transit(::google::protobuf::uint32 value) {
  set_has_transit();
  transit_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.TransportConfig.transit)
}

// -------------------------------------------------------------------

// TravelDetail

// required .IM.Buddy.TransportTool transport_tool = 1;
inline bool TravelDetail::has_transport_tool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TravelDetail::set_has_transport_tool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TravelDetail::clear_has_transport_tool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TravelDetail::clear_transport_tool() {
  if (transport_tool_ != NULL) transport_tool_->::IM::Buddy::TransportTool::Clear();
  clear_has_transport_tool();
}
inline const ::IM::Buddy::TransportTool& TravelDetail::transport_tool() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelDetail.transport_tool)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transport_tool_ != NULL ? *transport_tool_ : *default_instance().transport_tool_;
#else
  return transport_tool_ != NULL ? *transport_tool_ : *default_instance_->transport_tool_;
#endif
}
inline ::IM::Buddy::TransportTool* TravelDetail::mutable_transport_tool() {
  set_has_transport_tool();
  if (transport_tool_ == NULL) transport_tool_ = new ::IM::Buddy::TransportTool;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelDetail.transport_tool)
  return transport_tool_;
}
inline ::IM::Buddy::TransportTool* TravelDetail::release_transport_tool() {
  clear_has_transport_tool();
  ::IM::Buddy::TransportTool* temp = transport_tool_;
  transport_tool_ = NULL;
  return temp;
}
inline void TravelDetail::set_allocated_transport_tool(::IM::Buddy::TransportTool* transport_tool) {
  delete transport_tool_;
  transport_tool_ = transport_tool;
  if (transport_tool) {
    set_has_transport_tool();
  } else {
    clear_has_transport_tool();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelDetail.transport_tool)
}

// required .IM.Buddy.PlayDetail play_detail = 2;
inline bool TravelDetail::has_play_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TravelDetail::set_has_play_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TravelDetail::clear_has_play_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TravelDetail::clear_play_detail() {
  if (play_detail_ != NULL) play_detail_->::IM::Buddy::PlayDetail::Clear();
  clear_has_play_detail();
}
inline const ::IM::Buddy::PlayDetail& TravelDetail::play_detail() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TravelDetail.play_detail)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return play_detail_ != NULL ? *play_detail_ : *default_instance().play_detail_;
#else
  return play_detail_ != NULL ? *play_detail_ : *default_instance_->play_detail_;
#endif
}
inline ::IM::Buddy::PlayDetail* TravelDetail::mutable_play_detail() {
  set_has_play_detail();
  if (play_detail_ == NULL) play_detail_ = new ::IM::Buddy::PlayDetail;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TravelDetail.play_detail)
  return play_detail_;
}
inline ::IM::Buddy::PlayDetail* TravelDetail::release_play_detail() {
  clear_has_play_detail();
  ::IM::Buddy::PlayDetail* temp = play_detail_;
  play_detail_ = NULL;
  return temp;
}
inline void TravelDetail::set_allocated_play_detail(::IM::Buddy::PlayDetail* play_detail) {
  delete play_detail_;
  play_detail_ = play_detail;
  if (play_detail) {
    set_has_play_detail();
  } else {
    clear_has_play_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TravelDetail.play_detail)
}

// -------------------------------------------------------------------

// TransportTool

// required .IM.Buddy.TravelToolInfo from_info = 1;
inline bool TransportTool::has_from_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportTool::set_has_from_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportTool::clear_has_from_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportTool::clear_from_info() {
  if (from_info_ != NULL) from_info_->::IM::Buddy::TravelToolInfo::Clear();
  clear_has_from_info();
}
inline const ::IM::Buddy::TravelToolInfo& TransportTool::from_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TransportTool.from_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_info_ != NULL ? *from_info_ : *default_instance().from_info_;
#else
  return from_info_ != NULL ? *from_info_ : *default_instance_->from_info_;
#endif
}
inline ::IM::Buddy::TravelToolInfo* TransportTool::mutable_from_info() {
  set_has_from_info();
  if (from_info_ == NULL) from_info_ = new ::IM::Buddy::TravelToolInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TransportTool.from_info)
  return from_info_;
}
inline ::IM::Buddy::TravelToolInfo* TransportTool::release_from_info() {
  clear_has_from_info();
  ::IM::Buddy::TravelToolInfo* temp = from_info_;
  from_info_ = NULL;
  return temp;
}
inline void TransportTool::set_allocated_from_info(::IM::Buddy::TravelToolInfo* from_info) {
  delete from_info_;
  from_info_ = from_info;
  if (from_info) {
    set_has_from_info();
  } else {
    clear_has_from_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TransportTool.from_info)
}

// required .IM.Buddy.TravelToolInfo back_info = 2;
inline bool TransportTool::has_back_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportTool::set_has_back_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportTool::clear_has_back_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportTool::clear_back_info() {
  if (back_info_ != NULL) back_info_->::IM::Buddy::TravelToolInfo::Clear();
  clear_has_back_info();
}
inline const ::IM::Buddy::TravelToolInfo& TransportTool::back_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.TransportTool.back_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return back_info_ != NULL ? *back_info_ : *default_instance().back_info_;
#else
  return back_info_ != NULL ? *back_info_ : *default_instance_->back_info_;
#endif
}
inline ::IM::Buddy::TravelToolInfo* TransportTool::mutable_back_info() {
  set_has_back_info();
  if (back_info_ == NULL) back_info_ = new ::IM::Buddy::TravelToolInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.TransportTool.back_info)
  return back_info_;
}
inline ::IM::Buddy::TravelToolInfo* TransportTool::release_back_info() {
  clear_has_back_info();
  ::IM::Buddy::TravelToolInfo* temp = back_info_;
  back_info_ = NULL;
  return temp;
}
inline void TransportTool::set_allocated_back_info(::IM::Buddy::TravelToolInfo* back_info) {
  delete back_info_;
  back_info_ = back_info;
  if (back_info) {
    set_has_back_info();
  } else {
    clear_has_back_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.TransportTool.back_info)
}

// -------------------------------------------------------------------

// DayScenic

// required string dayTimeFrom = 1;
inline bool DayScenic::has_daytimefrom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DayScenic::set_has_daytimefrom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DayScenic::clear_has_daytimefrom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DayScenic::clear_daytimefrom() {
  if (daytimefrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_->clear();
  }
  clear_has_daytimefrom();
}
inline const ::std::string& DayScenic::daytimefrom() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayScenic.dayTimeFrom)
  return *daytimefrom_;
}
inline void DayScenic::set_daytimefrom(const ::std::string& value) {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  daytimefrom_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DayScenic.dayTimeFrom)
}
inline void DayScenic::set_daytimefrom(const char* value) {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  daytimefrom_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.DayScenic.dayTimeFrom)
}
inline void DayScenic::set_daytimefrom(const char* value, size_t size) {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  daytimefrom_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.DayScenic.dayTimeFrom)
}
inline ::std::string* DayScenic::mutable_daytimefrom() {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DayScenic.dayTimeFrom)
  return daytimefrom_;
}
inline ::std::string* DayScenic::release_daytimefrom() {
  clear_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = daytimefrom_;
    daytimefrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DayScenic::set_allocated_daytimefrom(::std::string* daytimefrom) {
  if (daytimefrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete daytimefrom_;
  }
  if (daytimefrom) {
    set_has_daytimefrom();
    daytimefrom_ = daytimefrom;
  } else {
    clear_has_daytimefrom();
    daytimefrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DayScenic.dayTimeFrom)
}

// required string dayTimeTo = 2;
inline bool DayScenic::has_daytimeto() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DayScenic::set_has_daytimeto() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DayScenic::clear_has_daytimeto() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DayScenic::clear_daytimeto() {
  if (daytimeto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_->clear();
  }
  clear_has_daytimeto();
}
inline const ::std::string& DayScenic::daytimeto() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayScenic.dayTimeTo)
  return *daytimeto_;
}
inline void DayScenic::set_daytimeto(const ::std::string& value) {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  daytimeto_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DayScenic.dayTimeTo)
}
inline void DayScenic::set_daytimeto(const char* value) {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  daytimeto_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.DayScenic.dayTimeTo)
}
inline void DayScenic::set_daytimeto(const char* value, size_t size) {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  daytimeto_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.DayScenic.dayTimeTo)
}
inline ::std::string* DayScenic::mutable_daytimeto() {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DayScenic.dayTimeTo)
  return daytimeto_;
}
inline ::std::string* DayScenic::release_daytimeto() {
  clear_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = daytimeto_;
    daytimeto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DayScenic::set_allocated_daytimeto(::std::string* daytimeto) {
  if (daytimeto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete daytimeto_;
  }
  if (daytimeto) {
    set_has_daytimeto();
    daytimeto_ = daytimeto;
  } else {
    clear_has_daytimeto();
    daytimeto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DayScenic.dayTimeTo)
}

// required .IM.Buddy.ScenicInfo scenic_info = 3;
inline bool DayScenic::has_scenic_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DayScenic::set_has_scenic_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DayScenic::clear_has_scenic_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DayScenic::clear_scenic_info() {
  if (scenic_info_ != NULL) scenic_info_->::IM::Buddy::ScenicInfo::Clear();
  clear_has_scenic_info();
}
inline const ::IM::Buddy::ScenicInfo& DayScenic::scenic_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayScenic.scenic_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenic_info_ != NULL ? *scenic_info_ : *default_instance().scenic_info_;
#else
  return scenic_info_ != NULL ? *scenic_info_ : *default_instance_->scenic_info_;
#endif
}
inline ::IM::Buddy::ScenicInfo* DayScenic::mutable_scenic_info() {
  set_has_scenic_info();
  if (scenic_info_ == NULL) scenic_info_ = new ::IM::Buddy::ScenicInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DayScenic.scenic_info)
  return scenic_info_;
}
inline ::IM::Buddy::ScenicInfo* DayScenic::release_scenic_info() {
  clear_has_scenic_info();
  ::IM::Buddy::ScenicInfo* temp = scenic_info_;
  scenic_info_ = NULL;
  return temp;
}
inline void DayScenic::set_allocated_scenic_info(::IM::Buddy::ScenicInfo* scenic_info) {
  delete scenic_info_;
  scenic_info_ = scenic_info;
  if (scenic_info) {
    set_has_scenic_info();
  } else {
    clear_has_scenic_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DayScenic.scenic_info)
}

// -------------------------------------------------------------------

// DayHotel

// required string dayTimeFrom = 1;
inline bool DayHotel::has_daytimefrom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DayHotel::set_has_daytimefrom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DayHotel::clear_has_daytimefrom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DayHotel::clear_daytimefrom() {
  if (daytimefrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_->clear();
  }
  clear_has_daytimefrom();
}
inline const ::std::string& DayHotel::daytimefrom() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayHotel.dayTimeFrom)
  return *daytimefrom_;
}
inline void DayHotel::set_daytimefrom(const ::std::string& value) {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  daytimefrom_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DayHotel.dayTimeFrom)
}
inline void DayHotel::set_daytimefrom(const char* value) {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  daytimefrom_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.DayHotel.dayTimeFrom)
}
inline void DayHotel::set_daytimefrom(const char* value, size_t size) {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  daytimefrom_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.DayHotel.dayTimeFrom)
}
inline ::std::string* DayHotel::mutable_daytimefrom() {
  set_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimefrom_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DayHotel.dayTimeFrom)
  return daytimefrom_;
}
inline ::std::string* DayHotel::release_daytimefrom() {
  clear_has_daytimefrom();
  if (daytimefrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = daytimefrom_;
    daytimefrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DayHotel::set_allocated_daytimefrom(::std::string* daytimefrom) {
  if (daytimefrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete daytimefrom_;
  }
  if (daytimefrom) {
    set_has_daytimefrom();
    daytimefrom_ = daytimefrom;
  } else {
    clear_has_daytimefrom();
    daytimefrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DayHotel.dayTimeFrom)
}

// required string dayTimeTo = 2;
inline bool DayHotel::has_daytimeto() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DayHotel::set_has_daytimeto() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DayHotel::clear_has_daytimeto() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DayHotel::clear_daytimeto() {
  if (daytimeto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_->clear();
  }
  clear_has_daytimeto();
}
inline const ::std::string& DayHotel::daytimeto() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayHotel.dayTimeTo)
  return *daytimeto_;
}
inline void DayHotel::set_daytimeto(const ::std::string& value) {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  daytimeto_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DayHotel.dayTimeTo)
}
inline void DayHotel::set_daytimeto(const char* value) {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  daytimeto_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.DayHotel.dayTimeTo)
}
inline void DayHotel::set_daytimeto(const char* value, size_t size) {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  daytimeto_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.DayHotel.dayTimeTo)
}
inline ::std::string* DayHotel::mutable_daytimeto() {
  set_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daytimeto_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DayHotel.dayTimeTo)
  return daytimeto_;
}
inline ::std::string* DayHotel::release_daytimeto() {
  clear_has_daytimeto();
  if (daytimeto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = daytimeto_;
    daytimeto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DayHotel::set_allocated_daytimeto(::std::string* daytimeto) {
  if (daytimeto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete daytimeto_;
  }
  if (daytimeto) {
    set_has_daytimeto();
    daytimeto_ = daytimeto;
  } else {
    clear_has_daytimeto();
    daytimeto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DayHotel.dayTimeTo)
}

// required .IM.Buddy.HotelInfo hotel_info = 3;
inline bool DayHotel::has_hotel_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DayHotel::set_has_hotel_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DayHotel::clear_has_hotel_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DayHotel::clear_hotel_info() {
  if (hotel_info_ != NULL) hotel_info_->::IM::Buddy::HotelInfo::Clear();
  clear_has_hotel_info();
}
inline const ::IM::Buddy::HotelInfo& DayHotel::hotel_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayHotel.hotel_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hotel_info_ != NULL ? *hotel_info_ : *default_instance().hotel_info_;
#else
  return hotel_info_ != NULL ? *hotel_info_ : *default_instance_->hotel_info_;
#endif
}
inline ::IM::Buddy::HotelInfo* DayHotel::mutable_hotel_info() {
  set_has_hotel_info();
  if (hotel_info_ == NULL) hotel_info_ = new ::IM::Buddy::HotelInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DayHotel.hotel_info)
  return hotel_info_;
}
inline ::IM::Buddy::HotelInfo* DayHotel::release_hotel_info() {
  clear_has_hotel_info();
  ::IM::Buddy::HotelInfo* temp = hotel_info_;
  hotel_info_ = NULL;
  return temp;
}
inline void DayHotel::set_allocated_hotel_info(::IM::Buddy::HotelInfo* hotel_info) {
  delete hotel_info_;
  hotel_info_ = hotel_info;
  if (hotel_info) {
    set_has_hotel_info();
  } else {
    clear_has_hotel_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DayHotel.hotel_info)
}

// -------------------------------------------------------------------

// PlayDetail

// required .IM.Buddy.PlayConfig play_config = 1;
inline bool PlayDetail::has_play_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayDetail::set_has_play_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayDetail::clear_has_play_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayDetail::clear_play_config() {
  if (play_config_ != NULL) play_config_->::IM::Buddy::PlayConfig::Clear();
  clear_has_play_config();
}
inline const ::IM::Buddy::PlayConfig& PlayDetail::play_config() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayDetail.play_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return play_config_ != NULL ? *play_config_ : *default_instance().play_config_;
#else
  return play_config_ != NULL ? *play_config_ : *default_instance_->play_config_;
#endif
}
inline ::IM::Buddy::PlayConfig* PlayDetail::mutable_play_config() {
  set_has_play_config();
  if (play_config_ == NULL) play_config_ = new ::IM::Buddy::PlayConfig;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.PlayDetail.play_config)
  return play_config_;
}
inline ::IM::Buddy::PlayConfig* PlayDetail::release_play_config() {
  clear_has_play_config();
  ::IM::Buddy::PlayConfig* temp = play_config_;
  play_config_ = NULL;
  return temp;
}
inline void PlayDetail::set_allocated_play_config(::IM::Buddy::PlayConfig* play_config) {
  delete play_config_;
  play_config_ = play_config;
  if (play_config) {
    set_has_play_config();
  } else {
    clear_has_play_config();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.PlayDetail.play_config)
}

// repeated .IM.Buddy.DayHotel day_hotel = 2;
inline int PlayDetail::day_hotel_size() const {
  return day_hotel_.size();
}
inline void PlayDetail::clear_day_hotel() {
  day_hotel_.Clear();
}
inline const ::IM::Buddy::DayHotel& PlayDetail::day_hotel(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayDetail.day_hotel)
  return day_hotel_.Get(index);
}
inline ::IM::Buddy::DayHotel* PlayDetail::mutable_day_hotel(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.PlayDetail.day_hotel)
  return day_hotel_.Mutable(index);
}
inline ::IM::Buddy::DayHotel* PlayDetail::add_day_hotel() {
  // @@protoc_insertion_point(field_add:IM.Buddy.PlayDetail.day_hotel)
  return day_hotel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayHotel >&
PlayDetail::day_hotel() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.PlayDetail.day_hotel)
  return day_hotel_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayHotel >*
PlayDetail::mutable_day_hotel() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.PlayDetail.day_hotel)
  return &day_hotel_;
}

// repeated .IM.Buddy.DayScenic day_scenic = 3;
inline int PlayDetail::day_scenic_size() const {
  return day_scenic_.size();
}
inline void PlayDetail::clear_day_scenic() {
  day_scenic_.Clear();
}
inline const ::IM::Buddy::DayScenic& PlayDetail::day_scenic(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayDetail.day_scenic)
  return day_scenic_.Get(index);
}
inline ::IM::Buddy::DayScenic* PlayDetail::mutable_day_scenic(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.PlayDetail.day_scenic)
  return day_scenic_.Mutable(index);
}
inline ::IM::Buddy::DayScenic* PlayDetail::add_day_scenic() {
  // @@protoc_insertion_point(field_add:IM.Buddy.PlayDetail.day_scenic)
  return day_scenic_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayScenic >&
PlayDetail::day_scenic() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.PlayDetail.day_scenic)
  return day_scenic_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayScenic >*
PlayDetail::mutable_day_scenic() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.PlayDetail.day_scenic)
  return &day_scenic_;
}

// -------------------------------------------------------------------

// PlayConfig

// required .IM.Buddy.QualityType quality = 1;
inline bool PlayConfig::has_quality() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayConfig::set_has_quality() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayConfig::clear_has_quality() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayConfig::clear_quality() {
  quality_ = 1;
  clear_has_quality();
}
inline ::IM::Buddy::QualityType PlayConfig::quality() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayConfig.quality)
  return static_cast< ::IM::Buddy::QualityType >(quality_);
}
inline void PlayConfig::set_quality(::IM::Buddy::QualityType value) {
  assert(::IM::Buddy::QualityType_IsValid(value));
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayConfig.quality)
}

// required string time_from = 2;
inline bool PlayConfig::has_time_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayConfig::set_has_time_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayConfig::clear_has_time_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayConfig::clear_time_from() {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_->clear();
  }
  clear_has_time_from();
}
inline const ::std::string& PlayConfig::time_from() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayConfig.time_from)
  return *time_from_;
}
inline void PlayConfig::set_time_from(const ::std::string& value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayConfig.time_from)
}
inline void PlayConfig::set_time_from(const char* value) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.PlayConfig.time_from)
}
inline void PlayConfig::set_time_from(const char* value, size_t size) {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  time_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.PlayConfig.time_from)
}
inline ::std::string* PlayConfig::mutable_time_from() {
  set_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.PlayConfig.time_from)
  return time_from_;
}
inline ::std::string* PlayConfig::release_time_from() {
  clear_has_time_from();
  if (time_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_from_;
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayConfig::set_allocated_time_from(::std::string* time_from) {
  if (time_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_from_;
  }
  if (time_from) {
    set_has_time_from();
    time_from_ = time_from;
  } else {
    clear_has_time_from();
    time_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.PlayConfig.time_from)
}

// required string time_to = 3;
inline bool PlayConfig::has_time_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayConfig::set_has_time_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayConfig::clear_has_time_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayConfig::clear_time_to() {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_->clear();
  }
  clear_has_time_to();
}
inline const ::std::string& PlayConfig::time_to() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayConfig.time_to)
  return *time_to_;
}
inline void PlayConfig::set_time_to(const ::std::string& value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayConfig.time_to)
}
inline void PlayConfig::set_time_to(const char* value) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.PlayConfig.time_to)
}
inline void PlayConfig::set_time_to(const char* value, size_t size) {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  time_to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.PlayConfig.time_to)
}
inline ::std::string* PlayConfig::mutable_time_to() {
  set_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.PlayConfig.time_to)
  return time_to_;
}
inline ::std::string* PlayConfig::release_time_to() {
  clear_has_time_to();
  if (time_to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_to_;
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayConfig::set_allocated_time_to(::std::string* time_to) {
  if (time_to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_to_;
  }
  if (time_to) {
    set_has_time_to();
    time_to_ = time_to;
  } else {
    clear_has_time_to();
    time_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.PlayConfig.time_to)
}

// required uint32 transport_tool_type = 4;
inline bool PlayConfig::has_transport_tool_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayConfig::set_has_transport_tool_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayConfig::clear_has_transport_tool_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayConfig::clear_transport_tool_type() {
  transport_tool_type_ = 0u;
  clear_has_transport_tool_type();
}
inline ::google::protobuf::uint32 PlayConfig::transport_tool_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayConfig.transport_tool_type)
  return transport_tool_type_;
}
inline void PlayConfig::set_transport_tool_type(::google::protobuf::uint32 value) {
  set_has_transport_tool_type();
  transport_tool_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayConfig.transport_tool_type)
}

// required .IM.Buddy.PositionType position = 5;
inline bool PlayConfig::has_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayConfig::set_has_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayConfig::clear_has_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayConfig::clear_position() {
  position_ = 1;
  clear_has_position();
}
inline ::IM::Buddy::PositionType PlayConfig::position() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.PlayConfig.position)
  return static_cast< ::IM::Buddy::PositionType >(position_);
}
inline void PlayConfig::set_position(::IM::Buddy::PositionType value) {
  assert(::IM::Buddy::PositionType_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.PlayConfig.position)
}

// -------------------------------------------------------------------

// ScenicInfo

// required uint32 id = 1;
inline bool ScenicInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenicInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenicInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenicInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ScenicInfo::id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.id)
  return id_;
}
inline void ScenicInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.id)
}

// required string city_code = 2;
inline bool ScenicInfo::has_city_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenicInfo::set_has_city_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenicInfo::clear_has_city_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenicInfo::clear_city_code() {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_->clear();
  }
  clear_has_city_code();
}
inline const ::std::string& ScenicInfo::city_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.city_code)
  return *city_code_;
}
inline void ScenicInfo::set_city_code(const ::std::string& value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.city_code)
}
inline void ScenicInfo::set_city_code(const char* value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.city_code)
}
inline void ScenicInfo::set_city_code(const char* value, size_t size) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.city_code)
}
inline ::std::string* ScenicInfo::mutable_city_code() {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.city_code)
  return city_code_;
}
inline ::std::string* ScenicInfo::release_city_code() {
  clear_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_code_;
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_city_code(::std::string* city_code) {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_code_;
  }
  if (city_code) {
    set_has_city_code();
    city_code_ = city_code;
  } else {
    clear_has_city_code();
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.city_code)
}

// required string sightName = 3;
inline bool ScenicInfo::has_sightname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenicInfo::set_has_sightname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenicInfo::clear_has_sightname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenicInfo::clear_sightname() {
  if (sightname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightname_->clear();
  }
  clear_has_sightname();
}
inline const ::std::string& ScenicInfo::sightname() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightName)
  return *sightname_;
}
inline void ScenicInfo::set_sightname(const ::std::string& value) {
  set_has_sightname();
  if (sightname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightname_ = new ::std::string;
  }
  sightname_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightName)
}
inline void ScenicInfo::set_sightname(const char* value) {
  set_has_sightname();
  if (sightname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightname_ = new ::std::string;
  }
  sightname_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightName)
}
inline void ScenicInfo::set_sightname(const char* value, size_t size) {
  set_has_sightname();
  if (sightname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightname_ = new ::std::string;
  }
  sightname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightName)
}
inline ::std::string* ScenicInfo::mutable_sightname() {
  set_has_sightname();
  if (sightname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightName)
  return sightname_;
}
inline ::std::string* ScenicInfo::release_sightname() {
  clear_has_sightname();
  if (sightname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightname_;
    sightname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightname(::std::string* sightname) {
  if (sightname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightname_;
  }
  if (sightname) {
    set_has_sightname();
    sightname_ = sightname;
  } else {
    clear_has_sightname();
    sightname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightName)
}

// required uint32 sightScore = 4;
inline bool ScenicInfo::has_sightscore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenicInfo::set_has_sightscore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenicInfo::clear_has_sightscore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenicInfo::clear_sightscore() {
  sightscore_ = 0u;
  clear_has_sightscore();
}
inline ::google::protobuf::uint32 ScenicInfo::sightscore() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightScore)
  return sightscore_;
}
inline void ScenicInfo::set_sightscore(::google::protobuf::uint32 value) {
  set_has_sightscore();
  sightscore_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightScore)
}

// required string sightTag = 5;
inline bool ScenicInfo::has_sighttag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenicInfo::set_has_sighttag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenicInfo::clear_has_sighttag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenicInfo::clear_sighttag() {
  if (sighttag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighttag_->clear();
  }
  clear_has_sighttag();
}
inline const ::std::string& ScenicInfo::sighttag() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightTag)
  return *sighttag_;
}
inline void ScenicInfo::set_sighttag(const ::std::string& value) {
  set_has_sighttag();
  if (sighttag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighttag_ = new ::std::string;
  }
  sighttag_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightTag)
}
inline void ScenicInfo::set_sighttag(const char* value) {
  set_has_sighttag();
  if (sighttag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighttag_ = new ::std::string;
  }
  sighttag_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightTag)
}
inline void ScenicInfo::set_sighttag(const char* value, size_t size) {
  set_has_sighttag();
  if (sighttag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighttag_ = new ::std::string;
  }
  sighttag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightTag)
}
inline ::std::string* ScenicInfo::mutable_sighttag() {
  set_has_sighttag();
  if (sighttag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighttag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightTag)
  return sighttag_;
}
inline ::std::string* ScenicInfo::release_sighttag() {
  clear_has_sighttag();
  if (sighttag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sighttag_;
    sighttag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sighttag(::std::string* sighttag) {
  if (sighttag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sighttag_;
  }
  if (sighttag) {
    set_has_sighttag();
    sighttag_ = sighttag;
  } else {
    clear_has_sighttag();
    sighttag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightTag)
}

// required string sightPic = 6;
inline bool ScenicInfo::has_sightpic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenicInfo::set_has_sightpic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenicInfo::clear_has_sightpic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenicInfo::clear_sightpic() {
  if (sightpic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightpic_->clear();
  }
  clear_has_sightpic();
}
inline const ::std::string& ScenicInfo::sightpic() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightPic)
  return *sightpic_;
}
inline void ScenicInfo::set_sightpic(const ::std::string& value) {
  set_has_sightpic();
  if (sightpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightpic_ = new ::std::string;
  }
  sightpic_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightPic)
}
inline void ScenicInfo::set_sightpic(const char* value) {
  set_has_sightpic();
  if (sightpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightpic_ = new ::std::string;
  }
  sightpic_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightPic)
}
inline void ScenicInfo::set_sightpic(const char* value, size_t size) {
  set_has_sightpic();
  if (sightpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightpic_ = new ::std::string;
  }
  sightpic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightPic)
}
inline ::std::string* ScenicInfo::mutable_sightpic() {
  set_has_sightpic();
  if (sightpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightpic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightPic)
  return sightpic_;
}
inline ::std::string* ScenicInfo::release_sightpic() {
  clear_has_sightpic();
  if (sightpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightpic_;
    sightpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightpic(::std::string* sightpic) {
  if (sightpic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightpic_;
  }
  if (sightpic) {
    set_has_sightpic();
    sightpic_ = sightpic;
  } else {
    clear_has_sightpic();
    sightpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightPic)
}

// required uint32 sightMustSee = 7;
inline bool ScenicInfo::has_sightmustsee() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenicInfo::set_has_sightmustsee() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenicInfo::clear_has_sightmustsee() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenicInfo::clear_sightmustsee() {
  sightmustsee_ = 0u;
  clear_has_sightmustsee();
}
inline ::google::protobuf::uint32 ScenicInfo::sightmustsee() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightMustSee)
  return sightmustsee_;
}
inline void ScenicInfo::set_sightmustsee(::google::protobuf::uint32 value) {
  set_has_sightmustsee();
  sightmustsee_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightMustSee)
}

// required string sightUrl = 8;
inline bool ScenicInfo::has_sighturl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScenicInfo::set_has_sighturl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScenicInfo::clear_has_sighturl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScenicInfo::clear_sighturl() {
  if (sighturl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighturl_->clear();
  }
  clear_has_sighturl();
}
inline const ::std::string& ScenicInfo::sighturl() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightUrl)
  return *sighturl_;
}
inline void ScenicInfo::set_sighturl(const ::std::string& value) {
  set_has_sighturl();
  if (sighturl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighturl_ = new ::std::string;
  }
  sighturl_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightUrl)
}
inline void ScenicInfo::set_sighturl(const char* value) {
  set_has_sighturl();
  if (sighturl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighturl_ = new ::std::string;
  }
  sighturl_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightUrl)
}
inline void ScenicInfo::set_sighturl(const char* value, size_t size) {
  set_has_sighturl();
  if (sighturl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighturl_ = new ::std::string;
  }
  sighturl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightUrl)
}
inline ::std::string* ScenicInfo::mutable_sighturl() {
  set_has_sighturl();
  if (sighturl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sighturl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightUrl)
  return sighturl_;
}
inline ::std::string* ScenicInfo::release_sighturl() {
  clear_has_sighturl();
  if (sighturl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sighturl_;
    sighturl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sighturl(::std::string* sighturl) {
  if (sighturl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sighturl_;
  }
  if (sighturl) {
    set_has_sighturl();
    sighturl_ = sighturl;
  } else {
    clear_has_sighturl();
    sighturl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightUrl)
}

// required string sightOpenTime = 9;
inline bool ScenicInfo::has_sightopentime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScenicInfo::set_has_sightopentime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScenicInfo::clear_has_sightopentime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScenicInfo::clear_sightopentime() {
  if (sightopentime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightopentime_->clear();
  }
  clear_has_sightopentime();
}
inline const ::std::string& ScenicInfo::sightopentime() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightOpenTime)
  return *sightopentime_;
}
inline void ScenicInfo::set_sightopentime(const ::std::string& value) {
  set_has_sightopentime();
  if (sightopentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightopentime_ = new ::std::string;
  }
  sightopentime_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightOpenTime)
}
inline void ScenicInfo::set_sightopentime(const char* value) {
  set_has_sightopentime();
  if (sightopentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightopentime_ = new ::std::string;
  }
  sightopentime_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightOpenTime)
}
inline void ScenicInfo::set_sightopentime(const char* value, size_t size) {
  set_has_sightopentime();
  if (sightopentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightopentime_ = new ::std::string;
  }
  sightopentime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightOpenTime)
}
inline ::std::string* ScenicInfo::mutable_sightopentime() {
  set_has_sightopentime();
  if (sightopentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightopentime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightOpenTime)
  return sightopentime_;
}
inline ::std::string* ScenicInfo::release_sightopentime() {
  clear_has_sightopentime();
  if (sightopentime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightopentime_;
    sightopentime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightopentime(::std::string* sightopentime) {
  if (sightopentime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightopentime_;
  }
  if (sightopentime) {
    set_has_sightopentime();
    sightopentime_ = sightopentime;
  } else {
    clear_has_sightopentime();
    sightopentime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightOpenTime)
}

// required uint32 sightPlayTime = 10;
inline bool ScenicInfo::has_sightplaytime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScenicInfo::set_has_sightplaytime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ScenicInfo::clear_has_sightplaytime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ScenicInfo::clear_sightplaytime() {
  sightplaytime_ = 0u;
  clear_has_sightplaytime();
}
inline ::google::protobuf::uint32 ScenicInfo::sightplaytime() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightPlayTime)
  return sightplaytime_;
}
inline void ScenicInfo::set_sightplaytime(::google::protobuf::uint32 value) {
  set_has_sightplaytime();
  sightplaytime_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightPlayTime)
}

// required uint32 sightPrice = 11;
inline bool ScenicInfo::has_sightprice() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ScenicInfo::set_has_sightprice() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ScenicInfo::clear_has_sightprice() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ScenicInfo::clear_sightprice() {
  sightprice_ = 0u;
  clear_has_sightprice();
}
inline ::google::protobuf::uint32 ScenicInfo::sightprice() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightPrice)
  return sightprice_;
}
inline void ScenicInfo::set_sightprice(::google::protobuf::uint32 value) {
  set_has_sightprice();
  sightprice_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightPrice)
}

// required string sightStartTime = 12;
inline bool ScenicInfo::has_sightstarttime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ScenicInfo::set_has_sightstarttime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ScenicInfo::clear_has_sightstarttime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ScenicInfo::clear_sightstarttime() {
  if (sightstarttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightstarttime_->clear();
  }
  clear_has_sightstarttime();
}
inline const ::std::string& ScenicInfo::sightstarttime() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightStartTime)
  return *sightstarttime_;
}
inline void ScenicInfo::set_sightstarttime(const ::std::string& value) {
  set_has_sightstarttime();
  if (sightstarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightstarttime_ = new ::std::string;
  }
  sightstarttime_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightStartTime)
}
inline void ScenicInfo::set_sightstarttime(const char* value) {
  set_has_sightstarttime();
  if (sightstarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightstarttime_ = new ::std::string;
  }
  sightstarttime_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightStartTime)
}
inline void ScenicInfo::set_sightstarttime(const char* value, size_t size) {
  set_has_sightstarttime();
  if (sightstarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightstarttime_ = new ::std::string;
  }
  sightstarttime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightStartTime)
}
inline ::std::string* ScenicInfo::mutable_sightstarttime() {
  set_has_sightstarttime();
  if (sightstarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightstarttime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightStartTime)
  return sightstarttime_;
}
inline ::std::string* ScenicInfo::release_sightstarttime() {
  clear_has_sightstarttime();
  if (sightstarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightstarttime_;
    sightstarttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightstarttime(::std::string* sightstarttime) {
  if (sightstarttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightstarttime_;
  }
  if (sightstarttime) {
    set_has_sightstarttime();
    sightstarttime_ = sightstarttime;
  } else {
    clear_has_sightstarttime();
    sightstarttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightStartTime)
}

// required string sightEndTime = 13;
inline bool ScenicInfo::has_sightendtime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ScenicInfo::set_has_sightendtime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ScenicInfo::clear_has_sightendtime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ScenicInfo::clear_sightendtime() {
  if (sightendtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightendtime_->clear();
  }
  clear_has_sightendtime();
}
inline const ::std::string& ScenicInfo::sightendtime() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightEndTime)
  return *sightendtime_;
}
inline void ScenicInfo::set_sightendtime(const ::std::string& value) {
  set_has_sightendtime();
  if (sightendtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightendtime_ = new ::std::string;
  }
  sightendtime_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightEndTime)
}
inline void ScenicInfo::set_sightendtime(const char* value) {
  set_has_sightendtime();
  if (sightendtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightendtime_ = new ::std::string;
  }
  sightendtime_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightEndTime)
}
inline void ScenicInfo::set_sightendtime(const char* value, size_t size) {
  set_has_sightendtime();
  if (sightendtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightendtime_ = new ::std::string;
  }
  sightendtime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightEndTime)
}
inline ::std::string* ScenicInfo::mutable_sightendtime() {
  set_has_sightendtime();
  if (sightendtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightendtime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightEndTime)
  return sightendtime_;
}
inline ::std::string* ScenicInfo::release_sightendtime() {
  clear_has_sightendtime();
  if (sightendtime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightendtime_;
    sightendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightendtime(::std::string* sightendtime) {
  if (sightendtime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightendtime_;
  }
  if (sightendtime) {
    set_has_sightendtime();
    sightendtime_ = sightendtime;
  } else {
    clear_has_sightendtime();
    sightendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightEndTime)
}

// required string sightLongitude = 14;
inline bool ScenicInfo::has_sightlongitude() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ScenicInfo::set_has_sightlongitude() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ScenicInfo::clear_has_sightlongitude() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ScenicInfo::clear_sightlongitude() {
  if (sightlongitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlongitude_->clear();
  }
  clear_has_sightlongitude();
}
inline const ::std::string& ScenicInfo::sightlongitude() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightLongitude)
  return *sightlongitude_;
}
inline void ScenicInfo::set_sightlongitude(const ::std::string& value) {
  set_has_sightlongitude();
  if (sightlongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlongitude_ = new ::std::string;
  }
  sightlongitude_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightLongitude)
}
inline void ScenicInfo::set_sightlongitude(const char* value) {
  set_has_sightlongitude();
  if (sightlongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlongitude_ = new ::std::string;
  }
  sightlongitude_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightLongitude)
}
inline void ScenicInfo::set_sightlongitude(const char* value, size_t size) {
  set_has_sightlongitude();
  if (sightlongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlongitude_ = new ::std::string;
  }
  sightlongitude_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightLongitude)
}
inline ::std::string* ScenicInfo::mutable_sightlongitude() {
  set_has_sightlongitude();
  if (sightlongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlongitude_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightLongitude)
  return sightlongitude_;
}
inline ::std::string* ScenicInfo::release_sightlongitude() {
  clear_has_sightlongitude();
  if (sightlongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightlongitude_;
    sightlongitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightlongitude(::std::string* sightlongitude) {
  if (sightlongitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightlongitude_;
  }
  if (sightlongitude) {
    set_has_sightlongitude();
    sightlongitude_ = sightlongitude;
  } else {
    clear_has_sightlongitude();
    sightlongitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightLongitude)
}

// required string sightLatitude = 15;
inline bool ScenicInfo::has_sightlatitude() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ScenicInfo::set_has_sightlatitude() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ScenicInfo::clear_has_sightlatitude() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ScenicInfo::clear_sightlatitude() {
  if (sightlatitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlatitude_->clear();
  }
  clear_has_sightlatitude();
}
inline const ::std::string& ScenicInfo::sightlatitude() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightLatitude)
  return *sightlatitude_;
}
inline void ScenicInfo::set_sightlatitude(const ::std::string& value) {
  set_has_sightlatitude();
  if (sightlatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlatitude_ = new ::std::string;
  }
  sightlatitude_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightLatitude)
}
inline void ScenicInfo::set_sightlatitude(const char* value) {
  set_has_sightlatitude();
  if (sightlatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlatitude_ = new ::std::string;
  }
  sightlatitude_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightLatitude)
}
inline void ScenicInfo::set_sightlatitude(const char* value, size_t size) {
  set_has_sightlatitude();
  if (sightlatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlatitude_ = new ::std::string;
  }
  sightlatitude_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightLatitude)
}
inline ::std::string* ScenicInfo::mutable_sightlatitude() {
  set_has_sightlatitude();
  if (sightlatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightlatitude_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightLatitude)
  return sightlatitude_;
}
inline ::std::string* ScenicInfo::release_sightlatitude() {
  clear_has_sightlatitude();
  if (sightlatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightlatitude_;
    sightlatitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightlatitude(::std::string* sightlatitude) {
  if (sightlatitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightlatitude_;
  }
  if (sightlatitude) {
    set_has_sightlatitude();
    sightlatitude_ = sightlatitude;
  } else {
    clear_has_sightlatitude();
    sightlatitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightLatitude)
}

// required string sightAddress = 16;
inline bool ScenicInfo::has_sightaddress() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ScenicInfo::set_has_sightaddress() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ScenicInfo::clear_has_sightaddress() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ScenicInfo::clear_sightaddress() {
  if (sightaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightaddress_->clear();
  }
  clear_has_sightaddress();
}
inline const ::std::string& ScenicInfo::sightaddress() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightAddress)
  return *sightaddress_;
}
inline void ScenicInfo::set_sightaddress(const ::std::string& value) {
  set_has_sightaddress();
  if (sightaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightaddress_ = new ::std::string;
  }
  sightaddress_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightAddress)
}
inline void ScenicInfo::set_sightaddress(const char* value) {
  set_has_sightaddress();
  if (sightaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightaddress_ = new ::std::string;
  }
  sightaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightAddress)
}
inline void ScenicInfo::set_sightaddress(const char* value, size_t size) {
  set_has_sightaddress();
  if (sightaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightaddress_ = new ::std::string;
  }
  sightaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightAddress)
}
inline ::std::string* ScenicInfo::mutable_sightaddress() {
  set_has_sightaddress();
  if (sightaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightAddress)
  return sightaddress_;
}
inline ::std::string* ScenicInfo::release_sightaddress() {
  clear_has_sightaddress();
  if (sightaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightaddress_;
    sightaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightaddress(::std::string* sightaddress) {
  if (sightaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightaddress_;
  }
  if (sightaddress) {
    set_has_sightaddress();
    sightaddress_ = sightaddress;
  } else {
    clear_has_sightaddress();
    sightaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightAddress)
}

// required string sightDiscription = 17;
inline bool ScenicInfo::has_sightdiscription() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ScenicInfo::set_has_sightdiscription() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ScenicInfo::clear_has_sightdiscription() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ScenicInfo::clear_sightdiscription() {
  if (sightdiscription_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscription_->clear();
  }
  clear_has_sightdiscription();
}
inline const ::std::string& ScenicInfo::sightdiscription() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightDiscription)
  return *sightdiscription_;
}
inline void ScenicInfo::set_sightdiscription(const ::std::string& value) {
  set_has_sightdiscription();
  if (sightdiscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscription_ = new ::std::string;
  }
  sightdiscription_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightDiscription)
}
inline void ScenicInfo::set_sightdiscription(const char* value) {
  set_has_sightdiscription();
  if (sightdiscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscription_ = new ::std::string;
  }
  sightdiscription_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightDiscription)
}
inline void ScenicInfo::set_sightdiscription(const char* value, size_t size) {
  set_has_sightdiscription();
  if (sightdiscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscription_ = new ::std::string;
  }
  sightdiscription_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightDiscription)
}
inline ::std::string* ScenicInfo::mutable_sightdiscription() {
  set_has_sightdiscription();
  if (sightdiscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscription_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightDiscription)
  return sightdiscription_;
}
inline ::std::string* ScenicInfo::release_sightdiscription() {
  clear_has_sightdiscription();
  if (sightdiscription_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightdiscription_;
    sightdiscription_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightdiscription(::std::string* sightdiscription) {
  if (sightdiscription_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightdiscription_;
  }
  if (sightdiscription) {
    set_has_sightdiscription();
    sightdiscription_ = sightdiscription;
  } else {
    clear_has_sightdiscription();
    sightdiscription_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightDiscription)
}

// required string sightDiscriptionDetail = 18;
inline bool ScenicInfo::has_sightdiscriptiondetail() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ScenicInfo::set_has_sightdiscriptiondetail() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ScenicInfo::clear_has_sightdiscriptiondetail() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ScenicInfo::clear_sightdiscriptiondetail() {
  if (sightdiscriptiondetail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscriptiondetail_->clear();
  }
  clear_has_sightdiscriptiondetail();
}
inline const ::std::string& ScenicInfo::sightdiscriptiondetail() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightDiscriptionDetail)
  return *sightdiscriptiondetail_;
}
inline void ScenicInfo::set_sightdiscriptiondetail(const ::std::string& value) {
  set_has_sightdiscriptiondetail();
  if (sightdiscriptiondetail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscriptiondetail_ = new ::std::string;
  }
  sightdiscriptiondetail_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightDiscriptionDetail)
}
inline void ScenicInfo::set_sightdiscriptiondetail(const char* value) {
  set_has_sightdiscriptiondetail();
  if (sightdiscriptiondetail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscriptiondetail_ = new ::std::string;
  }
  sightdiscriptiondetail_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.ScenicInfo.sightDiscriptionDetail)
}
inline void ScenicInfo::set_sightdiscriptiondetail(const char* value, size_t size) {
  set_has_sightdiscriptiondetail();
  if (sightdiscriptiondetail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscriptiondetail_ = new ::std::string;
  }
  sightdiscriptiondetail_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.ScenicInfo.sightDiscriptionDetail)
}
inline ::std::string* ScenicInfo::mutable_sightdiscriptiondetail() {
  set_has_sightdiscriptiondetail();
  if (sightdiscriptiondetail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sightdiscriptiondetail_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.ScenicInfo.sightDiscriptionDetail)
  return sightdiscriptiondetail_;
}
inline ::std::string* ScenicInfo::release_sightdiscriptiondetail() {
  clear_has_sightdiscriptiondetail();
  if (sightdiscriptiondetail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sightdiscriptiondetail_;
    sightdiscriptiondetail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ScenicInfo::set_allocated_sightdiscriptiondetail(::std::string* sightdiscriptiondetail) {
  if (sightdiscriptiondetail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sightdiscriptiondetail_;
  }
  if (sightdiscriptiondetail) {
    set_has_sightdiscriptiondetail();
    sightdiscriptiondetail_ = sightdiscriptiondetail;
  } else {
    clear_has_sightdiscriptiondetail();
    sightdiscriptiondetail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.ScenicInfo.sightDiscriptionDetail)
}

// required uint32 sightStatus = 19;
inline bool ScenicInfo::has_sightstatus() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ScenicInfo::set_has_sightstatus() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ScenicInfo::clear_has_sightstatus() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ScenicInfo::clear_sightstatus() {
  sightstatus_ = 0u;
  clear_has_sightstatus();
}
inline ::google::protobuf::uint32 ScenicInfo::sightstatus() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.sightStatus)
  return sightstatus_;
}
inline void ScenicInfo::set_sightstatus(::google::protobuf::uint32 value) {
  set_has_sightstatus();
  sightstatus_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.sightStatus)
}

// required uint32 literature = 20;
inline bool ScenicInfo::has_literature() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ScenicInfo::set_has_literature() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ScenicInfo::clear_has_literature() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ScenicInfo::clear_literature() {
  literature_ = 0u;
  clear_has_literature();
}
inline ::google::protobuf::uint32 ScenicInfo::literature() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.literature)
  return literature_;
}
inline void ScenicInfo::set_literature(::google::protobuf::uint32 value) {
  set_has_literature();
  literature_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.literature)
}

// required uint32 comfort = 21;
inline bool ScenicInfo::has_comfort() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ScenicInfo::set_has_comfort() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ScenicInfo::clear_has_comfort() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ScenicInfo::clear_comfort() {
  comfort_ = 0u;
  clear_has_comfort();
}
inline ::google::protobuf::uint32 ScenicInfo::comfort() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.comfort)
  return comfort_;
}
inline void ScenicInfo::set_comfort(::google::protobuf::uint32 value) {
  set_has_comfort();
  comfort_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.comfort)
}

// required uint32 exploration = 22;
inline bool ScenicInfo::has_exploration() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ScenicInfo::set_has_exploration() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ScenicInfo::clear_has_exploration() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ScenicInfo::clear_exploration() {
  exploration_ = 0u;
  clear_has_exploration();
}
inline ::google::protobuf::uint32 ScenicInfo::exploration() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.exploration)
  return exploration_;
}
inline void ScenicInfo::set_exploration(::google::protobuf::uint32 value) {
  set_has_exploration();
  exploration_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.exploration)
}

// required uint32 excite = 23;
inline bool ScenicInfo::has_excite() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ScenicInfo::set_has_excite() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ScenicInfo::clear_has_excite() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ScenicInfo::clear_excite() {
  excite_ = 0u;
  clear_has_excite();
}
inline ::google::protobuf::uint32 ScenicInfo::excite() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.excite)
  return excite_;
}
inline void ScenicInfo::set_excite(::google::protobuf::uint32 value) {
  set_has_excite();
  excite_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.excite)
}

// required uint32 encounter = 24;
inline bool ScenicInfo::has_encounter() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ScenicInfo::set_has_encounter() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ScenicInfo::clear_has_encounter() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ScenicInfo::clear_encounter() {
  encounter_ = 0u;
  clear_has_encounter();
}
inline ::google::protobuf::uint32 ScenicInfo::encounter() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.ScenicInfo.encounter)
  return encounter_;
}
inline void ScenicInfo::set_encounter(::google::protobuf::uint32 value) {
  set_has_encounter();
  encounter_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.ScenicInfo.encounter)
}

// -------------------------------------------------------------------

// HotelInfo

// required uint32 id = 1;
inline bool HotelInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HotelInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HotelInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HotelInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HotelInfo::id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.id)
  return id_;
}
inline void HotelInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.id)
}

// required string city_code = 2;
inline bool HotelInfo::has_city_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HotelInfo::set_has_city_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HotelInfo::clear_has_city_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HotelInfo::clear_city_code() {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_->clear();
  }
  clear_has_city_code();
}
inline const ::std::string& HotelInfo::city_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.city_code)
  return *city_code_;
}
inline void HotelInfo::set_city_code(const ::std::string& value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.city_code)
}
inline void HotelInfo::set_city_code(const char* value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.HotelInfo.city_code)
}
inline void HotelInfo::set_city_code(const char* value, size_t size) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.HotelInfo.city_code)
}
inline ::std::string* HotelInfo::mutable_city_code() {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.HotelInfo.city_code)
  return city_code_;
}
inline ::std::string* HotelInfo::release_city_code() {
  clear_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_code_;
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_city_code(::std::string* city_code) {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_code_;
  }
  if (city_code) {
    set_has_city_code();
    city_code_ = city_code;
  } else {
    clear_has_city_code();
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.HotelInfo.city_code)
}

// required string hotelName = 3;
inline bool HotelInfo::has_hotelname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HotelInfo::set_has_hotelname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HotelInfo::clear_has_hotelname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HotelInfo::clear_hotelname() {
  if (hotelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelname_->clear();
  }
  clear_has_hotelname();
}
inline const ::std::string& HotelInfo::hotelname() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelName)
  return *hotelname_;
}
inline void HotelInfo::set_hotelname(const ::std::string& value) {
  set_has_hotelname();
  if (hotelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelname_ = new ::std::string;
  }
  hotelname_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelName)
}
inline void HotelInfo::set_hotelname(const char* value) {
  set_has_hotelname();
  if (hotelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelname_ = new ::std::string;
  }
  hotelname_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.HotelInfo.hotelName)
}
inline void HotelInfo::set_hotelname(const char* value, size_t size) {
  set_has_hotelname();
  if (hotelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelname_ = new ::std::string;
  }
  hotelname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.HotelInfo.hotelName)
}
inline ::std::string* HotelInfo::mutable_hotelname() {
  set_has_hotelname();
  if (hotelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.HotelInfo.hotelName)
  return hotelname_;
}
inline ::std::string* HotelInfo::release_hotelname() {
  clear_has_hotelname();
  if (hotelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hotelname_;
    hotelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_hotelname(::std::string* hotelname) {
  if (hotelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hotelname_;
  }
  if (hotelname) {
    set_has_hotelname();
    hotelname_ = hotelname;
  } else {
    clear_has_hotelname();
    hotelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.HotelInfo.hotelName)
}

// required uint32 hotelScore = 4;
inline bool HotelInfo::has_hotelscore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HotelInfo::set_has_hotelscore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HotelInfo::clear_has_hotelscore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HotelInfo::clear_hotelscore() {
  hotelscore_ = 0u;
  clear_has_hotelscore();
}
inline ::google::protobuf::uint32 HotelInfo::hotelscore() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelScore)
  return hotelscore_;
}
inline void HotelInfo::set_hotelscore(::google::protobuf::uint32 value) {
  set_has_hotelscore();
  hotelscore_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelScore)
}

// required string hotelTag = 5;
inline bool HotelInfo::has_hoteltag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HotelInfo::set_has_hoteltag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HotelInfo::clear_has_hoteltag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HotelInfo::clear_hoteltag() {
  if (hoteltag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoteltag_->clear();
  }
  clear_has_hoteltag();
}
inline const ::std::string& HotelInfo::hoteltag() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelTag)
  return *hoteltag_;
}
inline void HotelInfo::set_hoteltag(const ::std::string& value) {
  set_has_hoteltag();
  if (hoteltag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoteltag_ = new ::std::string;
  }
  hoteltag_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelTag)
}
inline void HotelInfo::set_hoteltag(const char* value) {
  set_has_hoteltag();
  if (hoteltag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoteltag_ = new ::std::string;
  }
  hoteltag_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.HotelInfo.hotelTag)
}
inline void HotelInfo::set_hoteltag(const char* value, size_t size) {
  set_has_hoteltag();
  if (hoteltag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoteltag_ = new ::std::string;
  }
  hoteltag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.HotelInfo.hotelTag)
}
inline ::std::string* HotelInfo::mutable_hoteltag() {
  set_has_hoteltag();
  if (hoteltag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hoteltag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.HotelInfo.hotelTag)
  return hoteltag_;
}
inline ::std::string* HotelInfo::release_hoteltag() {
  clear_has_hoteltag();
  if (hoteltag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hoteltag_;
    hoteltag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_hoteltag(::std::string* hoteltag) {
  if (hoteltag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hoteltag_;
  }
  if (hoteltag) {
    set_has_hoteltag();
    hoteltag_ = hoteltag;
  } else {
    clear_has_hoteltag();
    hoteltag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.HotelInfo.hotelTag)
}

// required string hotelPic = 6;
inline bool HotelInfo::has_hotelpic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HotelInfo::set_has_hotelpic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HotelInfo::clear_has_hotelpic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HotelInfo::clear_hotelpic() {
  if (hotelpic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelpic_->clear();
  }
  clear_has_hotelpic();
}
inline const ::std::string& HotelInfo::hotelpic() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelPic)
  return *hotelpic_;
}
inline void HotelInfo::set_hotelpic(const ::std::string& value) {
  set_has_hotelpic();
  if (hotelpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelpic_ = new ::std::string;
  }
  hotelpic_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelPic)
}
inline void HotelInfo::set_hotelpic(const char* value) {
  set_has_hotelpic();
  if (hotelpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelpic_ = new ::std::string;
  }
  hotelpic_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.HotelInfo.hotelPic)
}
inline void HotelInfo::set_hotelpic(const char* value, size_t size) {
  set_has_hotelpic();
  if (hotelpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelpic_ = new ::std::string;
  }
  hotelpic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.HotelInfo.hotelPic)
}
inline ::std::string* HotelInfo::mutable_hotelpic() {
  set_has_hotelpic();
  if (hotelpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelpic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.HotelInfo.hotelPic)
  return hotelpic_;
}
inline ::std::string* HotelInfo::release_hotelpic() {
  clear_has_hotelpic();
  if (hotelpic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hotelpic_;
    hotelpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_hotelpic(::std::string* hotelpic) {
  if (hotelpic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hotelpic_;
  }
  if (hotelpic) {
    set_has_hotelpic();
    hotelpic_ = hotelpic;
  } else {
    clear_has_hotelpic();
    hotelpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.HotelInfo.hotelPic)
}

// required string hotelUrl = 7;
inline bool HotelInfo::has_hotelurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HotelInfo::set_has_hotelurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HotelInfo::clear_has_hotelurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HotelInfo::clear_hotelurl() {
  if (hotelurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelurl_->clear();
  }
  clear_has_hotelurl();
}
inline const ::std::string& HotelInfo::hotelurl() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelUrl)
  return *hotelurl_;
}
inline void HotelInfo::set_hotelurl(const ::std::string& value) {
  set_has_hotelurl();
  if (hotelurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelurl_ = new ::std::string;
  }
  hotelurl_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelUrl)
}
inline void HotelInfo::set_hotelurl(const char* value) {
  set_has_hotelurl();
  if (hotelurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelurl_ = new ::std::string;
  }
  hotelurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.HotelInfo.hotelUrl)
}
inline void HotelInfo::set_hotelurl(const char* value, size_t size) {
  set_has_hotelurl();
  if (hotelurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelurl_ = new ::std::string;
  }
  hotelurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.HotelInfo.hotelUrl)
}
inline ::std::string* HotelInfo::mutable_hotelurl() {
  set_has_hotelurl();
  if (hotelurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotelurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.HotelInfo.hotelUrl)
  return hotelurl_;
}
inline ::std::string* HotelInfo::release_hotelurl() {
  clear_has_hotelurl();
  if (hotelurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hotelurl_;
    hotelurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_hotelurl(::std::string* hotelurl) {
  if (hotelurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hotelurl_;
  }
  if (hotelurl) {
    set_has_hotelurl();
    hotelurl_ = hotelurl;
  } else {
    clear_has_hotelurl();
    hotelurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.HotelInfo.hotelUrl)
}

// required uint32 hotelPrice = 8;
inline bool HotelInfo::has_hotelprice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HotelInfo::set_has_hotelprice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HotelInfo::clear_has_hotelprice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HotelInfo::clear_hotelprice() {
  hotelprice_ = 0u;
  clear_has_hotelprice();
}
inline ::google::protobuf::uint32 HotelInfo::hotelprice() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelPrice)
  return hotelprice_;
}
inline void HotelInfo::set_hotelprice(::google::protobuf::uint32 value) {
  set_has_hotelprice();
  hotelprice_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelPrice)
}

// required string hotelLongitude = 9;
inline bool HotelInfo::has_hotellongitude() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HotelInfo::set_has_hotellongitude() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HotelInfo::clear_has_hotellongitude() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HotelInfo::clear_hotellongitude() {
  if (hotellongitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellongitude_->clear();
  }
  clear_has_hotellongitude();
}
inline const ::std::string& HotelInfo::hotellongitude() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelLongitude)
  return *hotellongitude_;
}
inline void HotelInfo::set_hotellongitude(const ::std::string& value) {
  set_has_hotellongitude();
  if (hotellongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellongitude_ = new ::std::string;
  }
  hotellongitude_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelLongitude)
}
inline void HotelInfo::set_hotellongitude(const char* value) {
  set_has_hotellongitude();
  if (hotellongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellongitude_ = new ::std::string;
  }
  hotellongitude_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.HotelInfo.hotelLongitude)
}
inline void HotelInfo::set_hotellongitude(const char* value, size_t size) {
  set_has_hotellongitude();
  if (hotellongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellongitude_ = new ::std::string;
  }
  hotellongitude_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.HotelInfo.hotelLongitude)
}
inline ::std::string* HotelInfo::mutable_hotellongitude() {
  set_has_hotellongitude();
  if (hotellongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellongitude_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.HotelInfo.hotelLongitude)
  return hotellongitude_;
}
inline ::std::string* HotelInfo::release_hotellongitude() {
  clear_has_hotellongitude();
  if (hotellongitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hotellongitude_;
    hotellongitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_hotellongitude(::std::string* hotellongitude) {
  if (hotellongitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hotellongitude_;
  }
  if (hotellongitude) {
    set_has_hotellongitude();
    hotellongitude_ = hotellongitude;
  } else {
    clear_has_hotellongitude();
    hotellongitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.HotelInfo.hotelLongitude)
}

// required string hotelLatitude = 10;
inline bool HotelInfo::has_hotellatitude() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HotelInfo::set_has_hotellatitude() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HotelInfo::clear_has_hotellatitude() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HotelInfo::clear_hotellatitude() {
  if (hotellatitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellatitude_->clear();
  }
  clear_has_hotellatitude();
}
inline const ::std::string& HotelInfo::hotellatitude() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.HotelInfo.hotelLatitude)
  return *hotellatitude_;
}
inline void HotelInfo::set_hotellatitude(const ::std::string& value) {
  set_has_hotellatitude();
  if (hotellatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellatitude_ = new ::std::string;
  }
  hotellatitude_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.HotelInfo.hotelLatitude)
}
inline void HotelInfo::set_hotellatitude(const char* value) {
  set_has_hotellatitude();
  if (hotellatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellatitude_ = new ::std::string;
  }
  hotellatitude_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.HotelInfo.hotelLatitude)
}
inline void HotelInfo::set_hotellatitude(const char* value, size_t size) {
  set_has_hotellatitude();
  if (hotellatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellatitude_ = new ::std::string;
  }
  hotellatitude_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.HotelInfo.hotelLatitude)
}
inline ::std::string* HotelInfo::mutable_hotellatitude() {
  set_has_hotellatitude();
  if (hotellatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hotellatitude_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.HotelInfo.hotelLatitude)
  return hotellatitude_;
}
inline ::std::string* HotelInfo::release_hotellatitude() {
  clear_has_hotellatitude();
  if (hotellatitude_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hotellatitude_;
    hotellatitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HotelInfo::set_allocated_hotellatitude(::std::string* hotellatitude) {
  if (hotellatitude_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hotellatitude_;
  }
  if (hotellatitude) {
    set_has_hotellatitude();
    hotellatitude_ = hotellatitude;
  } else {
    clear_has_hotellatitude();
    hotellatitude_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.HotelInfo.hotelLatitude)
}

// -------------------------------------------------------------------

// MyTravel

// required uint32 db_idx = 1;
inline bool MyTravel::has_db_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyTravel::set_has_db_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyTravel::clear_has_db_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyTravel::clear_db_idx() {
  db_idx_ = 0u;
  clear_has_db_idx();
}
inline ::google::protobuf::uint32 MyTravel::db_idx() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.MyTravel.db_idx)
  return db_idx_;
}
inline void MyTravel::set_db_idx(::google::protobuf::uint32 value) {
  set_has_db_idx();
  db_idx_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.MyTravel.db_idx)
}

// required uint32 cost = 2;
inline bool MyTravel::has_cost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyTravel::set_has_cost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyTravel::clear_has_cost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyTravel::clear_cost() {
  cost_ = 0u;
  clear_has_cost();
}
inline ::google::protobuf::uint32 MyTravel::cost() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.MyTravel.cost)
  return cost_;
}
inline void MyTravel::set_cost(::google::protobuf::uint32 value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.MyTravel.cost)
}

// required .IM.Buddy.BasicInfo basic_info = 3;
inline bool MyTravel::has_basic_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MyTravel::set_has_basic_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MyTravel::clear_has_basic_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MyTravel::clear_basic_info() {
  if (basic_info_ != NULL) basic_info_->::IM::Buddy::BasicInfo::Clear();
  clear_has_basic_info();
}
inline const ::IM::Buddy::BasicInfo& MyTravel::basic_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.MyTravel.basic_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return basic_info_ != NULL ? *basic_info_ : *default_instance().basic_info_;
#else
  return basic_info_ != NULL ? *basic_info_ : *default_instance_->basic_info_;
#endif
}
inline ::IM::Buddy::BasicInfo* MyTravel::mutable_basic_info() {
  set_has_basic_info();
  if (basic_info_ == NULL) basic_info_ = new ::IM::Buddy::BasicInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.MyTravel.basic_info)
  return basic_info_;
}
inline ::IM::Buddy::BasicInfo* MyTravel::release_basic_info() {
  clear_has_basic_info();
  ::IM::Buddy::BasicInfo* temp = basic_info_;
  basic_info_ = NULL;
  return temp;
}
inline void MyTravel::set_allocated_basic_info(::IM::Buddy::BasicInfo* basic_info) {
  delete basic_info_;
  basic_info_ = basic_info;
  if (basic_info) {
    set_has_basic_info();
  } else {
    clear_has_basic_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.MyTravel.basic_info)
}

// required .IM.Buddy.TransportConfig transport_config = 4;
inline bool MyTravel::has_transport_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MyTravel::set_has_transport_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MyTravel::clear_has_transport_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MyTravel::clear_transport_config() {
  if (transport_config_ != NULL) transport_config_->::IM::Buddy::TransportConfig::Clear();
  clear_has_transport_config();
}
inline const ::IM::Buddy::TransportConfig& MyTravel::transport_config() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.MyTravel.transport_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transport_config_ != NULL ? *transport_config_ : *default_instance().transport_config_;
#else
  return transport_config_ != NULL ? *transport_config_ : *default_instance_->transport_config_;
#endif
}
inline ::IM::Buddy::TransportConfig* MyTravel::mutable_transport_config() {
  set_has_transport_config();
  if (transport_config_ == NULL) transport_config_ = new ::IM::Buddy::TransportConfig;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.MyTravel.transport_config)
  return transport_config_;
}
inline ::IM::Buddy::TransportConfig* MyTravel::release_transport_config() {
  clear_has_transport_config();
  ::IM::Buddy::TransportConfig* temp = transport_config_;
  transport_config_ = NULL;
  return temp;
}
inline void MyTravel::set_allocated_transport_config(::IM::Buddy::TransportConfig* transport_config) {
  delete transport_config_;
  transport_config_ = transport_config;
  if (transport_config) {
    set_has_transport_config();
  } else {
    clear_has_transport_config();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.MyTravel.transport_config)
}

// required .IM.Buddy.TravelDetail travel_detail = 5;
inline bool MyTravel::has_travel_detail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MyTravel::set_has_travel_detail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MyTravel::clear_has_travel_detail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MyTravel::clear_travel_detail() {
  if (travel_detail_ != NULL) travel_detail_->::IM::Buddy::TravelDetail::Clear();
  clear_has_travel_detail();
}
inline const ::IM::Buddy::TravelDetail& MyTravel::travel_detail() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.MyTravel.travel_detail)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return travel_detail_ != NULL ? *travel_detail_ : *default_instance().travel_detail_;
#else
  return travel_detail_ != NULL ? *travel_detail_ : *default_instance_->travel_detail_;
#endif
}
inline ::IM::Buddy::TravelDetail* MyTravel::mutable_travel_detail() {
  set_has_travel_detail();
  if (travel_detail_ == NULL) travel_detail_ = new ::IM::Buddy::TravelDetail;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.MyTravel.travel_detail)
  return travel_detail_;
}
inline ::IM::Buddy::TravelDetail* MyTravel::release_travel_detail() {
  clear_has_travel_detail();
  ::IM::Buddy::TravelDetail* temp = travel_detail_;
  travel_detail_ = NULL;
  return temp;
}
inline void MyTravel::set_allocated_travel_detail(::IM::Buddy::TravelDetail* travel_detail) {
  delete travel_detail_;
  travel_detail_ = travel_detail;
  if (travel_detail) {
    set_has_travel_detail();
  } else {
    clear_has_travel_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.MyTravel.travel_detail)
}

// -------------------------------------------------------------------

// CreateMyTravelReq

// required uint32 user_id = 1;
inline bool CreateMyTravelReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateMyTravelReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateMyTravelReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateMyTravelReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 CreateMyTravelReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateMyTravelReq.user_id)
  return user_id_;
}
inline void CreateMyTravelReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateMyTravelReq.user_id)
}

// required .IM.Buddy.MyTravel my_travel = 2;
inline bool CreateMyTravelReq::has_my_travel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateMyTravelReq::set_has_my_travel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateMyTravelReq::clear_has_my_travel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateMyTravelReq::clear_my_travel() {
  if (my_travel_ != NULL) my_travel_->::IM::Buddy::MyTravel::Clear();
  clear_has_my_travel();
}
inline const ::IM::Buddy::MyTravel& CreateMyTravelReq::my_travel() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateMyTravelReq.my_travel)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return my_travel_ != NULL ? *my_travel_ : *default_instance().my_travel_;
#else
  return my_travel_ != NULL ? *my_travel_ : *default_instance_->my_travel_;
#endif
}
inline ::IM::Buddy::MyTravel* CreateMyTravelReq::mutable_my_travel() {
  set_has_my_travel();
  if (my_travel_ == NULL) my_travel_ = new ::IM::Buddy::MyTravel;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CreateMyTravelReq.my_travel)
  return my_travel_;
}
inline ::IM::Buddy::MyTravel* CreateMyTravelReq::release_my_travel() {
  clear_has_my_travel();
  ::IM::Buddy::MyTravel* temp = my_travel_;
  my_travel_ = NULL;
  return temp;
}
inline void CreateMyTravelReq::set_allocated_my_travel(::IM::Buddy::MyTravel* my_travel) {
  delete my_travel_;
  my_travel_ = my_travel;
  if (my_travel) {
    set_has_my_travel();
  } else {
    clear_has_my_travel();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CreateMyTravelReq.my_travel)
}

// optional bytes attach_data = 20;
inline bool CreateMyTravelReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateMyTravelReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateMyTravelReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateMyTravelReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& CreateMyTravelReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateMyTravelReq.attach_data)
  return *attach_data_;
}
inline void CreateMyTravelReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateMyTravelReq.attach_data)
}
inline void CreateMyTravelReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CreateMyTravelReq.attach_data)
}
inline void CreateMyTravelReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CreateMyTravelReq.attach_data)
}
inline ::std::string* CreateMyTravelReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CreateMyTravelReq.attach_data)
  return attach_data_;
}
inline ::std::string* CreateMyTravelReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateMyTravelReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CreateMyTravelReq.attach_data)
}

// -------------------------------------------------------------------

// CreateMyTravelRsp

// required uint32 user_id = 1;
inline bool CreateMyTravelRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateMyTravelRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateMyTravelRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateMyTravelRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 CreateMyTravelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateMyTravelRsp.user_id)
  return user_id_;
}
inline void CreateMyTravelRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateMyTravelRsp.user_id)
}

// required uint32 result_code = 2;
inline bool CreateMyTravelRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateMyTravelRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateMyTravelRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateMyTravelRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 CreateMyTravelRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateMyTravelRsp.result_code)
  return result_code_;
}
inline void CreateMyTravelRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateMyTravelRsp.result_code)
}

// required uint32 db_idx = 3;
inline bool CreateMyTravelRsp::has_db_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateMyTravelRsp::set_has_db_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateMyTravelRsp::clear_has_db_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateMyTravelRsp::clear_db_idx() {
  db_idx_ = 0u;
  clear_has_db_idx();
}
inline ::google::protobuf::uint32 CreateMyTravelRsp::db_idx() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateMyTravelRsp.db_idx)
  return db_idx_;
}
inline void CreateMyTravelRsp::set_db_idx(::google::protobuf::uint32 value) {
  set_has_db_idx();
  db_idx_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateMyTravelRsp.db_idx)
}

// optional bytes attach_data = 20;
inline bool CreateMyTravelRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateMyTravelRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateMyTravelRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateMyTravelRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& CreateMyTravelRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CreateMyTravelRsp.attach_data)
  return *attach_data_;
}
inline void CreateMyTravelRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CreateMyTravelRsp.attach_data)
}
inline void CreateMyTravelRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CreateMyTravelRsp.attach_data)
}
inline void CreateMyTravelRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CreateMyTravelRsp.attach_data)
}
inline ::std::string* CreateMyTravelRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CreateMyTravelRsp.attach_data)
  return attach_data_;
}
inline ::std::string* CreateMyTravelRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateMyTravelRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CreateMyTravelRsp.attach_data)
}

// -------------------------------------------------------------------

// DeleteMyTravelReq

// required uint32 user_id = 1;
inline bool DeleteMyTravelReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteMyTravelReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteMyTravelReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteMyTravelReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 DeleteMyTravelReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DeleteMyTravelReq.user_id)
  return user_id_;
}
inline void DeleteMyTravelReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.DeleteMyTravelReq.user_id)
}

// repeated uint32 db_idx = 2;
inline int DeleteMyTravelReq::db_idx_size() const {
  return db_idx_.size();
}
inline void DeleteMyTravelReq::clear_db_idx() {
  db_idx_.Clear();
}
inline ::google::protobuf::uint32 DeleteMyTravelReq::db_idx(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DeleteMyTravelReq.db_idx)
  return db_idx_.Get(index);
}
inline void DeleteMyTravelReq::set_db_idx(int index, ::google::protobuf::uint32 value) {
  db_idx_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DeleteMyTravelReq.db_idx)
}
inline void DeleteMyTravelReq::add_db_idx(::google::protobuf::uint32 value) {
  db_idx_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.DeleteMyTravelReq.db_idx)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DeleteMyTravelReq::db_idx() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.DeleteMyTravelReq.db_idx)
  return db_idx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DeleteMyTravelReq::mutable_db_idx() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.DeleteMyTravelReq.db_idx)
  return &db_idx_;
}

// optional bytes attach_data = 20;
inline bool DeleteMyTravelReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteMyTravelReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteMyTravelReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteMyTravelReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& DeleteMyTravelReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DeleteMyTravelReq.attach_data)
  return *attach_data_;
}
inline void DeleteMyTravelReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DeleteMyTravelReq.attach_data)
}
inline void DeleteMyTravelReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.DeleteMyTravelReq.attach_data)
}
inline void DeleteMyTravelReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.DeleteMyTravelReq.attach_data)
}
inline ::std::string* DeleteMyTravelReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DeleteMyTravelReq.attach_data)
  return attach_data_;
}
inline ::std::string* DeleteMyTravelReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteMyTravelReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DeleteMyTravelReq.attach_data)
}

// -------------------------------------------------------------------

// DeleteMyTravelRsp

// required uint32 user_id = 1;
inline bool DeleteMyTravelRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteMyTravelRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteMyTravelRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteMyTravelRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 DeleteMyTravelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DeleteMyTravelRsp.user_id)
  return user_id_;
}
inline void DeleteMyTravelRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.DeleteMyTravelRsp.user_id)
}

// required uint32 result_code = 2;
inline bool DeleteMyTravelRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteMyTravelRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteMyTravelRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteMyTravelRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 DeleteMyTravelRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DeleteMyTravelRsp.result_code)
  return result_code_;
}
inline void DeleteMyTravelRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.DeleteMyTravelRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool DeleteMyTravelRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteMyTravelRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteMyTravelRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteMyTravelRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& DeleteMyTravelRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DeleteMyTravelRsp.attach_data)
  return *attach_data_;
}
inline void DeleteMyTravelRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DeleteMyTravelRsp.attach_data)
}
inline void DeleteMyTravelRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.DeleteMyTravelRsp.attach_data)
}
inline void DeleteMyTravelRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.DeleteMyTravelRsp.attach_data)
}
inline ::std::string* DeleteMyTravelRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.DeleteMyTravelRsp.attach_data)
  return attach_data_;
}
inline ::std::string* DeleteMyTravelRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteMyTravelRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.DeleteMyTravelRsp.attach_data)
}

// -------------------------------------------------------------------

// UpdateMyTravelReq

// required uint32 user_id = 1;
inline bool UpdateMyTravelReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateMyTravelReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateMyTravelReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateMyTravelReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UpdateMyTravelReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.UpdateMyTravelReq.user_id)
  return user_id_;
}
inline void UpdateMyTravelReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.UpdateMyTravelReq.user_id)
}

// required uint32 db_idx = 2;
inline bool UpdateMyTravelReq::has_db_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateMyTravelReq::set_has_db_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateMyTravelReq::clear_has_db_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateMyTravelReq::clear_db_idx() {
  db_idx_ = 0u;
  clear_has_db_idx();
}
inline ::google::protobuf::uint32 UpdateMyTravelReq::db_idx() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.UpdateMyTravelReq.db_idx)
  return db_idx_;
}
inline void UpdateMyTravelReq::set_db_idx(::google::protobuf::uint32 value) {
  set_has_db_idx();
  db_idx_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.UpdateMyTravelReq.db_idx)
}

// required .IM.Buddy.MyTravel my_travel = 3;
inline bool UpdateMyTravelReq::has_my_travel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateMyTravelReq::set_has_my_travel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateMyTravelReq::clear_has_my_travel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateMyTravelReq::clear_my_travel() {
  if (my_travel_ != NULL) my_travel_->::IM::Buddy::MyTravel::Clear();
  clear_has_my_travel();
}
inline const ::IM::Buddy::MyTravel& UpdateMyTravelReq::my_travel() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.UpdateMyTravelReq.my_travel)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return my_travel_ != NULL ? *my_travel_ : *default_instance().my_travel_;
#else
  return my_travel_ != NULL ? *my_travel_ : *default_instance_->my_travel_;
#endif
}
inline ::IM::Buddy::MyTravel* UpdateMyTravelReq::mutable_my_travel() {
  set_has_my_travel();
  if (my_travel_ == NULL) my_travel_ = new ::IM::Buddy::MyTravel;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.UpdateMyTravelReq.my_travel)
  return my_travel_;
}
inline ::IM::Buddy::MyTravel* UpdateMyTravelReq::release_my_travel() {
  clear_has_my_travel();
  ::IM::Buddy::MyTravel* temp = my_travel_;
  my_travel_ = NULL;
  return temp;
}
inline void UpdateMyTravelReq::set_allocated_my_travel(::IM::Buddy::MyTravel* my_travel) {
  delete my_travel_;
  my_travel_ = my_travel;
  if (my_travel) {
    set_has_my_travel();
  } else {
    clear_has_my_travel();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.UpdateMyTravelReq.my_travel)
}

// optional bytes attach_data = 20;
inline bool UpdateMyTravelReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateMyTravelReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateMyTravelReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateMyTravelReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& UpdateMyTravelReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.UpdateMyTravelReq.attach_data)
  return *attach_data_;
}
inline void UpdateMyTravelReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.UpdateMyTravelReq.attach_data)
}
inline void UpdateMyTravelReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.UpdateMyTravelReq.attach_data)
}
inline void UpdateMyTravelReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.UpdateMyTravelReq.attach_data)
}
inline ::std::string* UpdateMyTravelReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.UpdateMyTravelReq.attach_data)
  return attach_data_;
}
inline ::std::string* UpdateMyTravelReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateMyTravelReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.UpdateMyTravelReq.attach_data)
}

// -------------------------------------------------------------------

// UpdateMyTravelRsp

// required uint32 user_id = 1;
inline bool UpdateMyTravelRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateMyTravelRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateMyTravelRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateMyTravelRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UpdateMyTravelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.UpdateMyTravelRsp.user_id)
  return user_id_;
}
inline void UpdateMyTravelRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.UpdateMyTravelRsp.user_id)
}

// required uint32 result_code = 2;
inline bool UpdateMyTravelRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateMyTravelRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateMyTravelRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateMyTravelRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 UpdateMyTravelRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.UpdateMyTravelRsp.result_code)
  return result_code_;
}
inline void UpdateMyTravelRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.UpdateMyTravelRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool UpdateMyTravelRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateMyTravelRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateMyTravelRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateMyTravelRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& UpdateMyTravelRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.UpdateMyTravelRsp.attach_data)
  return *attach_data_;
}
inline void UpdateMyTravelRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.UpdateMyTravelRsp.attach_data)
}
inline void UpdateMyTravelRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.UpdateMyTravelRsp.attach_data)
}
inline void UpdateMyTravelRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.UpdateMyTravelRsp.attach_data)
}
inline ::std::string* UpdateMyTravelRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.UpdateMyTravelRsp.attach_data)
  return attach_data_;
}
inline ::std::string* UpdateMyTravelRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateMyTravelRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.UpdateMyTravelRsp.attach_data)
}

// -------------------------------------------------------------------

// QueryMyTravelReq

// required uint32 user_id = 1;
inline bool QueryMyTravelReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMyTravelReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMyTravelReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMyTravelReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 QueryMyTravelReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.QueryMyTravelReq.user_id)
  return user_id_;
}
inline void QueryMyTravelReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.QueryMyTravelReq.user_id)
}

// optional bytes attach_data = 20;
inline bool QueryMyTravelReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryMyTravelReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryMyTravelReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryMyTravelReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& QueryMyTravelReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.QueryMyTravelReq.attach_data)
  return *attach_data_;
}
inline void QueryMyTravelReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.QueryMyTravelReq.attach_data)
}
inline void QueryMyTravelReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.QueryMyTravelReq.attach_data)
}
inline void QueryMyTravelReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.QueryMyTravelReq.attach_data)
}
inline ::std::string* QueryMyTravelReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.QueryMyTravelReq.attach_data)
  return attach_data_;
}
inline ::std::string* QueryMyTravelReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QueryMyTravelReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.QueryMyTravelReq.attach_data)
}

// -------------------------------------------------------------------

// QueryMyTravelRsp

// required uint32 user_id = 1;
inline bool QueryMyTravelRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMyTravelRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMyTravelRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMyTravelRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 QueryMyTravelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.QueryMyTravelRsp.user_id)
  return user_id_;
}
inline void QueryMyTravelRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.QueryMyTravelRsp.user_id)
}

// required uint32 result_code = 2;
inline bool QueryMyTravelRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryMyTravelRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryMyTravelRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryMyTravelRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 QueryMyTravelRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.QueryMyTravelRsp.result_code)
  return result_code_;
}
inline void QueryMyTravelRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.QueryMyTravelRsp.result_code)
}

// repeated .IM.Buddy.MyTravel my_travel = 3;
inline int QueryMyTravelRsp::my_travel_size() const {
  return my_travel_.size();
}
inline void QueryMyTravelRsp::clear_my_travel() {
  my_travel_.Clear();
}
inline const ::IM::Buddy::MyTravel& QueryMyTravelRsp::my_travel(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.QueryMyTravelRsp.my_travel)
  return my_travel_.Get(index);
}
inline ::IM::Buddy::MyTravel* QueryMyTravelRsp::mutable_my_travel(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.QueryMyTravelRsp.my_travel)
  return my_travel_.Mutable(index);
}
inline ::IM::Buddy::MyTravel* QueryMyTravelRsp::add_my_travel() {
  // @@protoc_insertion_point(field_add:IM.Buddy.QueryMyTravelRsp.my_travel)
  return my_travel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::MyTravel >&
QueryMyTravelRsp::my_travel() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.QueryMyTravelRsp.my_travel)
  return my_travel_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::MyTravel >*
QueryMyTravelRsp::mutable_my_travel() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.QueryMyTravelRsp.my_travel)
  return &my_travel_;
}

// optional bytes attach_data = 20;
inline bool QueryMyTravelRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryMyTravelRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryMyTravelRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryMyTravelRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& QueryMyTravelRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.QueryMyTravelRsp.attach_data)
  return *attach_data_;
}
inline void QueryMyTravelRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.QueryMyTravelRsp.attach_data)
}
inline void QueryMyTravelRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.QueryMyTravelRsp.attach_data)
}
inline void QueryMyTravelRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.QueryMyTravelRsp.attach_data)
}
inline ::std::string* QueryMyTravelRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.QueryMyTravelRsp.attach_data)
  return attach_data_;
}
inline ::std::string* QueryMyTravelRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QueryMyTravelRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.QueryMyTravelRsp.attach_data)
}

// -------------------------------------------------------------------

// GetTransportToolReq

// required uint32 user_id = 1;
inline bool GetTransportToolReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTransportToolReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTransportToolReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTransportToolReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 GetTransportToolReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolReq.user_id)
  return user_id_;
}
inline void GetTransportToolReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTransportToolReq.user_id)
}

// required .IM.Buddy.BasicInfo basic_info = 2;
inline bool GetTransportToolReq::has_basic_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTransportToolReq::set_has_basic_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTransportToolReq::clear_has_basic_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTransportToolReq::clear_basic_info() {
  if (basic_info_ != NULL) basic_info_->::IM::Buddy::BasicInfo::Clear();
  clear_has_basic_info();
}
inline const ::IM::Buddy::BasicInfo& GetTransportToolReq::basic_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolReq.basic_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return basic_info_ != NULL ? *basic_info_ : *default_instance().basic_info_;
#else
  return basic_info_ != NULL ? *basic_info_ : *default_instance_->basic_info_;
#endif
}
inline ::IM::Buddy::BasicInfo* GetTransportToolReq::mutable_basic_info() {
  set_has_basic_info();
  if (basic_info_ == NULL) basic_info_ = new ::IM::Buddy::BasicInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTransportToolReq.basic_info)
  return basic_info_;
}
inline ::IM::Buddy::BasicInfo* GetTransportToolReq::release_basic_info() {
  clear_has_basic_info();
  ::IM::Buddy::BasicInfo* temp = basic_info_;
  basic_info_ = NULL;
  return temp;
}
inline void GetTransportToolReq::set_allocated_basic_info(::IM::Buddy::BasicInfo* basic_info) {
  delete basic_info_;
  basic_info_ = basic_info;
  if (basic_info) {
    set_has_basic_info();
  } else {
    clear_has_basic_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetTransportToolReq.basic_info)
}

// required .IM.Buddy.TransportConfig transport_config = 3;
inline bool GetTransportToolReq::has_transport_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTransportToolReq::set_has_transport_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTransportToolReq::clear_has_transport_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTransportToolReq::clear_transport_config() {
  if (transport_config_ != NULL) transport_config_->::IM::Buddy::TransportConfig::Clear();
  clear_has_transport_config();
}
inline const ::IM::Buddy::TransportConfig& GetTransportToolReq::transport_config() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolReq.transport_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transport_config_ != NULL ? *transport_config_ : *default_instance().transport_config_;
#else
  return transport_config_ != NULL ? *transport_config_ : *default_instance_->transport_config_;
#endif
}
inline ::IM::Buddy::TransportConfig* GetTransportToolReq::mutable_transport_config() {
  set_has_transport_config();
  if (transport_config_ == NULL) transport_config_ = new ::IM::Buddy::TransportConfig;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTransportToolReq.transport_config)
  return transport_config_;
}
inline ::IM::Buddy::TransportConfig* GetTransportToolReq::release_transport_config() {
  clear_has_transport_config();
  ::IM::Buddy::TransportConfig* temp = transport_config_;
  transport_config_ = NULL;
  return temp;
}
inline void GetTransportToolReq::set_allocated_transport_config(::IM::Buddy::TransportConfig* transport_config) {
  delete transport_config_;
  transport_config_ = transport_config;
  if (transport_config) {
    set_has_transport_config();
  } else {
    clear_has_transport_config();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetTransportToolReq.transport_config)
}

// optional bytes attach_data = 20;
inline bool GetTransportToolReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetTransportToolReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetTransportToolReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetTransportToolReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetTransportToolReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolReq.attach_data)
  return *attach_data_;
}
inline void GetTransportToolReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTransportToolReq.attach_data)
}
inline void GetTransportToolReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.GetTransportToolReq.attach_data)
}
inline void GetTransportToolReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.GetTransportToolReq.attach_data)
}
inline ::std::string* GetTransportToolReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTransportToolReq.attach_data)
  return attach_data_;
}
inline ::std::string* GetTransportToolReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTransportToolReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetTransportToolReq.attach_data)
}

// -------------------------------------------------------------------

// GetTransportToolRsp

// required uint32 user_id = 1;
inline bool GetTransportToolRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTransportToolRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTransportToolRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTransportToolRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 GetTransportToolRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolRsp.user_id)
  return user_id_;
}
inline void GetTransportToolRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTransportToolRsp.user_id)
}

// required uint32 result_code = 2;
inline bool GetTransportToolRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTransportToolRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTransportToolRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTransportToolRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 GetTransportToolRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolRsp.result_code)
  return result_code_;
}
inline void GetTransportToolRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTransportToolRsp.result_code)
}

// repeated .IM.Buddy.TravelToolInfo travel_tool_info = 3;
inline int GetTransportToolRsp::travel_tool_info_size() const {
  return travel_tool_info_.size();
}
inline void GetTransportToolRsp::clear_travel_tool_info() {
  travel_tool_info_.Clear();
}
inline const ::IM::Buddy::TravelToolInfo& GetTransportToolRsp::travel_tool_info(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolRsp.travel_tool_info)
  return travel_tool_info_.Get(index);
}
inline ::IM::Buddy::TravelToolInfo* GetTransportToolRsp::mutable_travel_tool_info(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTransportToolRsp.travel_tool_info)
  return travel_tool_info_.Mutable(index);
}
inline ::IM::Buddy::TravelToolInfo* GetTransportToolRsp::add_travel_tool_info() {
  // @@protoc_insertion_point(field_add:IM.Buddy.GetTransportToolRsp.travel_tool_info)
  return travel_tool_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >&
GetTransportToolRsp::travel_tool_info() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.GetTransportToolRsp.travel_tool_info)
  return travel_tool_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::TravelToolInfo >*
GetTransportToolRsp::mutable_travel_tool_info() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.GetTransportToolRsp.travel_tool_info)
  return &travel_tool_info_;
}

// optional bytes attach_data = 20;
inline bool GetTransportToolRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetTransportToolRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetTransportToolRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetTransportToolRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetTransportToolRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetTransportToolRsp.attach_data)
  return *attach_data_;
}
inline void GetTransportToolRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.GetTransportToolRsp.attach_data)
}
inline void GetTransportToolRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.GetTransportToolRsp.attach_data)
}
inline void GetTransportToolRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.GetTransportToolRsp.attach_data)
}
inline ::std::string* GetTransportToolRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetTransportToolRsp.attach_data)
  return attach_data_;
}
inline ::std::string* GetTransportToolRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTransportToolRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetTransportToolRsp.attach_data)
}

// -------------------------------------------------------------------

// GetScenicHotelReq

// required uint32 user_id = 1;
inline bool GetScenicHotelReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetScenicHotelReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetScenicHotelReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetScenicHotelReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 GetScenicHotelReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelReq.user_id)
  return user_id_;
}
inline void GetScenicHotelReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetScenicHotelReq.user_id)
}

// required string city_code = 2;
inline bool GetScenicHotelReq::has_city_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetScenicHotelReq::set_has_city_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetScenicHotelReq::clear_has_city_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetScenicHotelReq::clear_city_code() {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_->clear();
  }
  clear_has_city_code();
}
inline const ::std::string& GetScenicHotelReq::city_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelReq.city_code)
  return *city_code_;
}
inline void GetScenicHotelReq::set_city_code(const ::std::string& value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.GetScenicHotelReq.city_code)
}
inline void GetScenicHotelReq::set_city_code(const char* value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.GetScenicHotelReq.city_code)
}
inline void GetScenicHotelReq::set_city_code(const char* value, size_t size) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.GetScenicHotelReq.city_code)
}
inline ::std::string* GetScenicHotelReq::mutable_city_code() {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetScenicHotelReq.city_code)
  return city_code_;
}
inline ::std::string* GetScenicHotelReq::release_city_code() {
  clear_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_code_;
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetScenicHotelReq::set_allocated_city_code(::std::string* city_code) {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_code_;
  }
  if (city_code) {
    set_has_city_code();
    city_code_ = city_code;
  } else {
    clear_has_city_code();
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetScenicHotelReq.city_code)
}

// optional bytes attach_data = 20;
inline bool GetScenicHotelReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetScenicHotelReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetScenicHotelReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetScenicHotelReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetScenicHotelReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelReq.attach_data)
  return *attach_data_;
}
inline void GetScenicHotelReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.GetScenicHotelReq.attach_data)
}
inline void GetScenicHotelReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.GetScenicHotelReq.attach_data)
}
inline void GetScenicHotelReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.GetScenicHotelReq.attach_data)
}
inline ::std::string* GetScenicHotelReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetScenicHotelReq.attach_data)
  return attach_data_;
}
inline ::std::string* GetScenicHotelReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetScenicHotelReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetScenicHotelReq.attach_data)
}

// -------------------------------------------------------------------

// GetScenicHotelRsp

// required uint32 user_id = 1;
inline bool GetScenicHotelRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetScenicHotelRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetScenicHotelRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetScenicHotelRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 GetScenicHotelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelRsp.user_id)
  return user_id_;
}
inline void GetScenicHotelRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetScenicHotelRsp.user_id)
}

// required uint32 result_code = 2;
inline bool GetScenicHotelRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetScenicHotelRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetScenicHotelRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetScenicHotelRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 GetScenicHotelRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelRsp.result_code)
  return result_code_;
}
inline void GetScenicHotelRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.GetScenicHotelRsp.result_code)
}

// repeated .IM.Buddy.ScenicInfo scenic_info = 3;
inline int GetScenicHotelRsp::scenic_info_size() const {
  return scenic_info_.size();
}
inline void GetScenicHotelRsp::clear_scenic_info() {
  scenic_info_.Clear();
}
inline const ::IM::Buddy::ScenicInfo& GetScenicHotelRsp::scenic_info(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelRsp.scenic_info)
  return scenic_info_.Get(index);
}
inline ::IM::Buddy::ScenicInfo* GetScenicHotelRsp::mutable_scenic_info(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetScenicHotelRsp.scenic_info)
  return scenic_info_.Mutable(index);
}
inline ::IM::Buddy::ScenicInfo* GetScenicHotelRsp::add_scenic_info() {
  // @@protoc_insertion_point(field_add:IM.Buddy.GetScenicHotelRsp.scenic_info)
  return scenic_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::ScenicInfo >&
GetScenicHotelRsp::scenic_info() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.GetScenicHotelRsp.scenic_info)
  return scenic_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::ScenicInfo >*
GetScenicHotelRsp::mutable_scenic_info() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.GetScenicHotelRsp.scenic_info)
  return &scenic_info_;
}

// repeated .IM.Buddy.HotelInfo hotel_info = 4;
inline int GetScenicHotelRsp::hotel_info_size() const {
  return hotel_info_.size();
}
inline void GetScenicHotelRsp::clear_hotel_info() {
  hotel_info_.Clear();
}
inline const ::IM::Buddy::HotelInfo& GetScenicHotelRsp::hotel_info(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelRsp.hotel_info)
  return hotel_info_.Get(index);
}
inline ::IM::Buddy::HotelInfo* GetScenicHotelRsp::mutable_hotel_info(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetScenicHotelRsp.hotel_info)
  return hotel_info_.Mutable(index);
}
inline ::IM::Buddy::HotelInfo* GetScenicHotelRsp::add_hotel_info() {
  // @@protoc_insertion_point(field_add:IM.Buddy.GetScenicHotelRsp.hotel_info)
  return hotel_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::HotelInfo >&
GetScenicHotelRsp::hotel_info() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.GetScenicHotelRsp.hotel_info)
  return hotel_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::HotelInfo >*
GetScenicHotelRsp::mutable_hotel_info() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.GetScenicHotelRsp.hotel_info)
  return &hotel_info_;
}

// optional bytes attach_data = 20;
inline bool GetScenicHotelRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetScenicHotelRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetScenicHotelRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetScenicHotelRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetScenicHotelRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.GetScenicHotelRsp.attach_data)
  return *attach_data_;
}
inline void GetScenicHotelRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.GetScenicHotelRsp.attach_data)
}
inline void GetScenicHotelRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.GetScenicHotelRsp.attach_data)
}
inline void GetScenicHotelRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.GetScenicHotelRsp.attach_data)
}
inline ::std::string* GetScenicHotelRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.GetScenicHotelRsp.attach_data)
  return attach_data_;
}
inline ::std::string* GetScenicHotelRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetScenicHotelRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.GetScenicHotelRsp.attach_data)
}

// -------------------------------------------------------------------

// DayRoute

// repeated uint32 scenics = 1;
inline int DayRoute::scenics_size() const {
  return scenics_.size();
}
inline void DayRoute::clear_scenics() {
  scenics_.Clear();
}
inline ::google::protobuf::uint32 DayRoute::scenics(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayRoute.scenics)
  return scenics_.Get(index);
}
inline void DayRoute::set_scenics(int index, ::google::protobuf::uint32 value) {
  scenics_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DayRoute.scenics)
}
inline void DayRoute::add_scenics(::google::protobuf::uint32 value) {
  scenics_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.DayRoute.scenics)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DayRoute::scenics() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.DayRoute.scenics)
  return scenics_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DayRoute::mutable_scenics() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.DayRoute.scenics)
  return &scenics_;
}

// repeated uint32 hotels = 2;
inline int DayRoute::hotels_size() const {
  return hotels_.size();
}
inline void DayRoute::clear_hotels() {
  hotels_.Clear();
}
inline ::google::protobuf::uint32 DayRoute::hotels(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.DayRoute.hotels)
  return hotels_.Get(index);
}
inline void DayRoute::set_hotels(int index, ::google::protobuf::uint32 value) {
  hotels_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.DayRoute.hotels)
}
inline void DayRoute::add_hotels(::google::protobuf::uint32 value) {
  hotels_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.DayRoute.hotels)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DayRoute::hotels() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.DayRoute.hotels)
  return hotels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DayRoute::mutable_hotels() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.DayRoute.hotels)
  return &hotels_;
}

// -------------------------------------------------------------------

// Route

// required uint32 id = 1;
inline bool Route::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Route::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Route::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Route::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Route::id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.id)
  return id_;
}
inline void Route::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.id)
}

// required uint32 day_count = 2;
inline bool Route::has_day_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Route::set_has_day_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Route::clear_has_day_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Route::clear_day_count() {
  day_count_ = 0u;
  clear_has_day_count();
}
inline ::google::protobuf::uint32 Route::day_count() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.day_count)
  return day_count_;
}
inline void Route::set_day_count(::google::protobuf::uint32 value) {
  set_has_day_count();
  day_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.day_count)
}

// required string city_code = 3;
inline bool Route::has_city_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Route::set_has_city_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Route::clear_has_city_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Route::clear_city_code() {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_->clear();
  }
  clear_has_city_code();
}
inline const ::std::string& Route::city_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.city_code)
  return *city_code_;
}
inline void Route::set_city_code(const ::std::string& value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.city_code)
}
inline void Route::set_city_code(const char* value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.Route.city_code)
}
inline void Route::set_city_code(const char* value, size_t size) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.Route.city_code)
}
inline ::std::string* Route::mutable_city_code() {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Route.city_code)
  return city_code_;
}
inline ::std::string* Route::release_city_code() {
  clear_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_code_;
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Route::set_allocated_city_code(::std::string* city_code) {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_code_;
  }
  if (city_code) {
    set_has_city_code();
    city_code_ = city_code;
  } else {
    clear_has_city_code();
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.Route.city_code)
}

// repeated string tag = 4;
inline int Route::tag_size() const {
  return tag_.size();
}
inline void Route::clear_tag() {
  tag_.Clear();
}
inline const ::std::string& Route::tag(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.tag)
  return tag_.Get(index);
}
inline ::std::string* Route::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Route.tag)
  return tag_.Mutable(index);
}
inline void Route::set_tag(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.tag)
  tag_.Mutable(index)->assign(value);
}
inline void Route::set_tag(int index, const char* value) {
  tag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.Route.tag)
}
inline void Route::set_tag(int index, const char* value, size_t size) {
  tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.Route.tag)
}
inline ::std::string* Route::add_tag() {
  return tag_.Add();
}
inline void Route::add_tag(const ::std::string& value) {
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.Route.tag)
}
inline void Route::add_tag(const char* value) {
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IM.Buddy.Route.tag)
}
inline void Route::add_tag(const char* value, size_t size) {
  tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IM.Buddy.Route.tag)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Route::tag() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.Route.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Route::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.Route.tag)
  return &tag_;
}

// required .IM.Buddy.TransportToolType start_transport_tool = 5;
inline bool Route::has_start_transport_tool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Route::set_has_start_transport_tool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Route::clear_has_start_transport_tool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Route::clear_start_transport_tool() {
  start_transport_tool_ = 1;
  clear_has_start_transport_tool();
}
inline ::IM::Buddy::TransportToolType Route::start_transport_tool() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.start_transport_tool)
  return static_cast< ::IM::Buddy::TransportToolType >(start_transport_tool_);
}
inline void Route::set_start_transport_tool(::IM::Buddy::TransportToolType value) {
  assert(::IM::Buddy::TransportToolType_IsValid(value));
  set_has_start_transport_tool();
  start_transport_tool_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.start_transport_tool)
}

// required .IM.Buddy.TransportToolType end_transport_tool = 6;
inline bool Route::has_end_transport_tool() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Route::set_has_end_transport_tool() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Route::clear_has_end_transport_tool() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Route::clear_end_transport_tool() {
  end_transport_tool_ = 1;
  clear_has_end_transport_tool();
}
inline ::IM::Buddy::TransportToolType Route::end_transport_tool() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.end_transport_tool)
  return static_cast< ::IM::Buddy::TransportToolType >(end_transport_tool_);
}
inline void Route::set_end_transport_tool(::IM::Buddy::TransportToolType value) {
  assert(::IM::Buddy::TransportToolType_IsValid(value));
  set_has_end_transport_tool();
  end_transport_tool_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.end_transport_tool)
}

// required string start_time = 7;
inline bool Route::has_start_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Route::set_has_start_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Route::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Route::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& Route::start_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.start_time)
  return *start_time_;
}
inline void Route::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.start_time)
}
inline void Route::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.Route.start_time)
}
inline void Route::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.Route.start_time)
}
inline ::std::string* Route::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Route.start_time)
  return start_time_;
}
inline ::std::string* Route::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Route::set_allocated_start_time(::std::string* start_time) {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_time_;
  }
  if (start_time) {
    set_has_start_time();
    start_time_ = start_time;
  } else {
    clear_has_start_time();
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.Route.start_time)
}

// required string end_time = 8;
inline bool Route::has_end_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Route::set_has_end_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Route::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Route::clear_end_time() {
  if (end_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_->clear();
  }
  clear_has_end_time();
}
inline const ::std::string& Route::end_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.end_time)
  return *end_time_;
}
inline void Route::set_end_time(const ::std::string& value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.Route.end_time)
}
inline void Route::set_end_time(const char* value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.Route.end_time)
}
inline void Route::set_end_time(const char* value, size_t size) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.Route.end_time)
}
inline ::std::string* Route::mutable_end_time() {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Route.end_time)
  return end_time_;
}
inline ::std::string* Route::release_end_time() {
  clear_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_time_;
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Route::set_allocated_end_time(::std::string* end_time) {
  if (end_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_time_;
  }
  if (end_time) {
    set_has_end_time();
    end_time_ = end_time;
  } else {
    clear_has_end_time();
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.Route.end_time)
}

// repeated .IM.Buddy.DayRoute day_routes = 9;
inline int Route::day_routes_size() const {
  return day_routes_.size();
}
inline void Route::clear_day_routes() {
  day_routes_.Clear();
}
inline const ::IM::Buddy::DayRoute& Route::day_routes(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Route.day_routes)
  return day_routes_.Get(index);
}
inline ::IM::Buddy::DayRoute* Route::mutable_day_routes(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Route.day_routes)
  return day_routes_.Mutable(index);
}
inline ::IM::Buddy::DayRoute* Route::add_day_routes() {
  // @@protoc_insertion_point(field_add:IM.Buddy.Route.day_routes)
  return day_routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayRoute >&
Route::day_routes() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.Route.day_routes)
  return day_routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::DayRoute >*
Route::mutable_day_routes() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.Route.day_routes)
  return &day_routes_;
}

// -------------------------------------------------------------------

// CollectionRoute

// required uint32 id = 1;
inline bool CollectionRoute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectionRoute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectionRoute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectionRoute::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CollectionRoute::id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CollectionRoute.id)
  return id_;
}
inline void CollectionRoute::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.CollectionRoute.id)
}

// required string start_date = 2;
inline bool CollectionRoute::has_start_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollectionRoute::set_has_start_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollectionRoute::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollectionRoute::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& CollectionRoute::start_date() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CollectionRoute.start_date)
  return *start_date_;
}
inline void CollectionRoute::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CollectionRoute.start_date)
}
inline void CollectionRoute::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CollectionRoute.start_date)
}
inline void CollectionRoute::set_start_date(const char* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CollectionRoute.start_date)
}
inline ::std::string* CollectionRoute::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CollectionRoute.start_date)
  return start_date_;
}
inline ::std::string* CollectionRoute::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CollectionRoute::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CollectionRoute.start_date)
}

// required string end_date = 3;
inline bool CollectionRoute::has_end_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollectionRoute::set_has_end_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollectionRoute::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollectionRoute::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& CollectionRoute::end_date() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CollectionRoute.end_date)
  return *end_date_;
}
inline void CollectionRoute::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CollectionRoute.end_date)
}
inline void CollectionRoute::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CollectionRoute.end_date)
}
inline void CollectionRoute::set_end_date(const char* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CollectionRoute.end_date)
}
inline ::std::string* CollectionRoute::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CollectionRoute.end_date)
  return end_date_;
}
inline ::std::string* CollectionRoute::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CollectionRoute::set_allocated_end_date(::std::string* end_date) {
  if (end_date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_date_;
  }
  if (end_date) {
    set_has_end_date();
    end_date_ = end_date;
  } else {
    clear_has_end_date();
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CollectionRoute.end_date)
}

// required string start_traffic_no = 4;
inline bool CollectionRoute::has_start_traffic_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollectionRoute::set_has_start_traffic_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollectionRoute::clear_has_start_traffic_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollectionRoute::clear_start_traffic_no() {
  if (start_traffic_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_traffic_no_->clear();
  }
  clear_has_start_traffic_no();
}
inline const ::std::string& CollectionRoute::start_traffic_no() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CollectionRoute.start_traffic_no)
  return *start_traffic_no_;
}
inline void CollectionRoute::set_start_traffic_no(const ::std::string& value) {
  set_has_start_traffic_no();
  if (start_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_traffic_no_ = new ::std::string;
  }
  start_traffic_no_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CollectionRoute.start_traffic_no)
}
inline void CollectionRoute::set_start_traffic_no(const char* value) {
  set_has_start_traffic_no();
  if (start_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_traffic_no_ = new ::std::string;
  }
  start_traffic_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CollectionRoute.start_traffic_no)
}
inline void CollectionRoute::set_start_traffic_no(const char* value, size_t size) {
  set_has_start_traffic_no();
  if (start_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_traffic_no_ = new ::std::string;
  }
  start_traffic_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CollectionRoute.start_traffic_no)
}
inline ::std::string* CollectionRoute::mutable_start_traffic_no() {
  set_has_start_traffic_no();
  if (start_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_traffic_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CollectionRoute.start_traffic_no)
  return start_traffic_no_;
}
inline ::std::string* CollectionRoute::release_start_traffic_no() {
  clear_has_start_traffic_no();
  if (start_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_traffic_no_;
    start_traffic_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CollectionRoute::set_allocated_start_traffic_no(::std::string* start_traffic_no) {
  if (start_traffic_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_traffic_no_;
  }
  if (start_traffic_no) {
    set_has_start_traffic_no();
    start_traffic_no_ = start_traffic_no;
  } else {
    clear_has_start_traffic_no();
    start_traffic_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CollectionRoute.start_traffic_no)
}

// required string end_traffic_no = 5;
inline bool CollectionRoute::has_end_traffic_no() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollectionRoute::set_has_end_traffic_no() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollectionRoute::clear_has_end_traffic_no() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollectionRoute::clear_end_traffic_no() {
  if (end_traffic_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_traffic_no_->clear();
  }
  clear_has_end_traffic_no();
}
inline const ::std::string& CollectionRoute::end_traffic_no() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CollectionRoute.end_traffic_no)
  return *end_traffic_no_;
}
inline void CollectionRoute::set_end_traffic_no(const ::std::string& value) {
  set_has_end_traffic_no();
  if (end_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_traffic_no_ = new ::std::string;
  }
  end_traffic_no_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.CollectionRoute.end_traffic_no)
}
inline void CollectionRoute::set_end_traffic_no(const char* value) {
  set_has_end_traffic_no();
  if (end_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_traffic_no_ = new ::std::string;
  }
  end_traffic_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.CollectionRoute.end_traffic_no)
}
inline void CollectionRoute::set_end_traffic_no(const char* value, size_t size) {
  set_has_end_traffic_no();
  if (end_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_traffic_no_ = new ::std::string;
  }
  end_traffic_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.CollectionRoute.end_traffic_no)
}
inline ::std::string* CollectionRoute::mutable_end_traffic_no() {
  set_has_end_traffic_no();
  if (end_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_traffic_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CollectionRoute.end_traffic_no)
  return end_traffic_no_;
}
inline ::std::string* CollectionRoute::release_end_traffic_no() {
  clear_has_end_traffic_no();
  if (end_traffic_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_traffic_no_;
    end_traffic_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CollectionRoute::set_allocated_end_traffic_no(::std::string* end_traffic_no) {
  if (end_traffic_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_traffic_no_;
  }
  if (end_traffic_no) {
    set_has_end_traffic_no();
    end_traffic_no_ = end_traffic_no;
  } else {
    clear_has_end_traffic_no();
    end_traffic_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CollectionRoute.end_traffic_no)
}

// required .IM.Buddy.Route route = 6;
inline bool CollectionRoute::has_route() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollectionRoute::set_has_route() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollectionRoute::clear_has_route() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollectionRoute::clear_route() {
  if (route_ != NULL) route_->::IM::Buddy::Route::Clear();
  clear_has_route();
}
inline const ::IM::Buddy::Route& CollectionRoute::route() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.CollectionRoute.route)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return route_ != NULL ? *route_ : *default_instance().route_;
#else
  return route_ != NULL ? *route_ : *default_instance_->route_;
#endif
}
inline ::IM::Buddy::Route* CollectionRoute::mutable_route() {
  set_has_route();
  if (route_ == NULL) route_ = new ::IM::Buddy::Route;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.CollectionRoute.route)
  return route_;
}
inline ::IM::Buddy::Route* CollectionRoute::release_route() {
  clear_has_route();
  ::IM::Buddy::Route* temp = route_;
  route_ = NULL;
  return temp;
}
inline void CollectionRoute::set_allocated_route(::IM::Buddy::Route* route) {
  delete route_;
  route_ = route;
  if (route) {
    set_has_route();
  } else {
    clear_has_route();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.CollectionRoute.route)
}

// -------------------------------------------------------------------

// NewQueryRadomRouteReq

// required uint32 user_id = 1;
inline bool NewQueryRadomRouteReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewQueryRadomRouteReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewQueryRadomRouteReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewQueryRadomRouteReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewQueryRadomRouteReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteReq.user_id)
  return user_id_;
}
inline void NewQueryRadomRouteReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryRadomRouteReq.user_id)
}

// repeated string tags = 2;
inline int NewQueryRadomRouteReq::tags_size() const {
  return tags_.size();
}
inline void NewQueryRadomRouteReq::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& NewQueryRadomRouteReq::tags(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteReq.tags)
  return tags_.Get(index);
}
inline ::std::string* NewQueryRadomRouteReq::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryRadomRouteReq.tags)
  return tags_.Mutable(index);
}
inline void NewQueryRadomRouteReq::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryRadomRouteReq.tags)
  tags_.Mutable(index)->assign(value);
}
inline void NewQueryRadomRouteReq::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewQueryRadomRouteReq.tags)
}
inline void NewQueryRadomRouteReq::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewQueryRadomRouteReq.tags)
}
inline ::std::string* NewQueryRadomRouteReq::add_tags() {
  return tags_.Add();
}
inline void NewQueryRadomRouteReq::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.NewQueryRadomRouteReq.tags)
}
inline void NewQueryRadomRouteReq::add_tags(const char* value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IM.Buddy.NewQueryRadomRouteReq.tags)
}
inline void NewQueryRadomRouteReq::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IM.Buddy.NewQueryRadomRouteReq.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NewQueryRadomRouteReq::tags() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.NewQueryRadomRouteReq.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NewQueryRadomRouteReq::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.NewQueryRadomRouteReq.tags)
  return &tags_;
}

// required string sentence = 3;
inline bool NewQueryRadomRouteReq::has_sentence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewQueryRadomRouteReq::set_has_sentence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewQueryRadomRouteReq::clear_has_sentence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewQueryRadomRouteReq::clear_sentence() {
  if (sentence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_->clear();
  }
  clear_has_sentence();
}
inline const ::std::string& NewQueryRadomRouteReq::sentence() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteReq.sentence)
  return *sentence_;
}
inline void NewQueryRadomRouteReq::set_sentence(const ::std::string& value) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryRadomRouteReq.sentence)
}
inline void NewQueryRadomRouteReq::set_sentence(const char* value) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewQueryRadomRouteReq.sentence)
}
inline void NewQueryRadomRouteReq::set_sentence(const char* value, size_t size) {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  sentence_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewQueryRadomRouteReq.sentence)
}
inline ::std::string* NewQueryRadomRouteReq::mutable_sentence() {
  set_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sentence_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryRadomRouteReq.sentence)
  return sentence_;
}
inline ::std::string* NewQueryRadomRouteReq::release_sentence() {
  clear_has_sentence();
  if (sentence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sentence_;
    sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewQueryRadomRouteReq::set_allocated_sentence(::std::string* sentence) {
  if (sentence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sentence_;
  }
  if (sentence) {
    set_has_sentence();
    sentence_ = sentence;
  } else {
    clear_has_sentence();
    sentence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewQueryRadomRouteReq.sentence)
}

// optional bytes attach_data = 20;
inline bool NewQueryRadomRouteReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewQueryRadomRouteReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewQueryRadomRouteReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewQueryRadomRouteReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewQueryRadomRouteReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteReq.attach_data)
  return *attach_data_;
}
inline void NewQueryRadomRouteReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryRadomRouteReq.attach_data)
}
inline void NewQueryRadomRouteReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewQueryRadomRouteReq.attach_data)
}
inline void NewQueryRadomRouteReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewQueryRadomRouteReq.attach_data)
}
inline ::std::string* NewQueryRadomRouteReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryRadomRouteReq.attach_data)
  return attach_data_;
}
inline ::std::string* NewQueryRadomRouteReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewQueryRadomRouteReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewQueryRadomRouteReq.attach_data)
}

// -------------------------------------------------------------------

// NewQueryRadomRouteRsp

// required uint32 user_id = 1;
inline bool NewQueryRadomRouteRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewQueryRadomRouteRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewQueryRadomRouteRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewQueryRadomRouteRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewQueryRadomRouteRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteRsp.user_id)
  return user_id_;
}
inline void NewQueryRadomRouteRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryRadomRouteRsp.user_id)
}

// required uint32 result_code = 2;
inline bool NewQueryRadomRouteRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewQueryRadomRouteRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewQueryRadomRouteRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewQueryRadomRouteRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 NewQueryRadomRouteRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteRsp.result_code)
  return result_code_;
}
inline void NewQueryRadomRouteRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryRadomRouteRsp.result_code)
}

// repeated .IM.Buddy.Route routes = 3;
inline int NewQueryRadomRouteRsp::routes_size() const {
  return routes_.size();
}
inline void NewQueryRadomRouteRsp::clear_routes() {
  routes_.Clear();
}
inline const ::IM::Buddy::Route& NewQueryRadomRouteRsp::routes(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteRsp.routes)
  return routes_.Get(index);
}
inline ::IM::Buddy::Route* NewQueryRadomRouteRsp::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryRadomRouteRsp.routes)
  return routes_.Mutable(index);
}
inline ::IM::Buddy::Route* NewQueryRadomRouteRsp::add_routes() {
  // @@protoc_insertion_point(field_add:IM.Buddy.NewQueryRadomRouteRsp.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::Route >&
NewQueryRadomRouteRsp::routes() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.NewQueryRadomRouteRsp.routes)
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::Route >*
NewQueryRadomRouteRsp::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.NewQueryRadomRouteRsp.routes)
  return &routes_;
}

// optional bytes attach_data = 20;
inline bool NewQueryRadomRouteRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewQueryRadomRouteRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewQueryRadomRouteRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewQueryRadomRouteRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewQueryRadomRouteRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryRadomRouteRsp.attach_data)
  return *attach_data_;
}
inline void NewQueryRadomRouteRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryRadomRouteRsp.attach_data)
}
inline void NewQueryRadomRouteRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewQueryRadomRouteRsp.attach_data)
}
inline void NewQueryRadomRouteRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewQueryRadomRouteRsp.attach_data)
}
inline ::std::string* NewQueryRadomRouteRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryRadomRouteRsp.attach_data)
  return attach_data_;
}
inline ::std::string* NewQueryRadomRouteRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewQueryRadomRouteRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewQueryRadomRouteRsp.attach_data)
}

// -------------------------------------------------------------------

// NewUpdateRadomRouteReq

// required uint32 user_id = 1;
inline bool NewUpdateRadomRouteReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewUpdateRadomRouteReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewUpdateRadomRouteReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewUpdateRadomRouteReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.user_id)
  return user_id_;
}
inline void NewUpdateRadomRouteReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.user_id)
}

// required uint32 day_count = 2;
inline bool NewUpdateRadomRouteReq::has_day_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_day_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewUpdateRadomRouteReq::clear_has_day_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewUpdateRadomRouteReq::clear_day_count() {
  day_count_ = 0u;
  clear_has_day_count();
}
inline ::google::protobuf::uint32 NewUpdateRadomRouteReq::day_count() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.day_count)
  return day_count_;
}
inline void NewUpdateRadomRouteReq::set_day_count(::google::protobuf::uint32 value) {
  set_has_day_count();
  day_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.day_count)
}

// required string city_code = 3;
inline bool NewUpdateRadomRouteReq::has_city_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_city_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewUpdateRadomRouteReq::clear_has_city_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewUpdateRadomRouteReq::clear_city_code() {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_->clear();
  }
  clear_has_city_code();
}
inline const ::std::string& NewUpdateRadomRouteReq::city_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.city_code)
  return *city_code_;
}
inline void NewUpdateRadomRouteReq::set_city_code(const ::std::string& value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.city_code)
}
inline void NewUpdateRadomRouteReq::set_city_code(const char* value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewUpdateRadomRouteReq.city_code)
}
inline void NewUpdateRadomRouteReq::set_city_code(const char* value, size_t size) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewUpdateRadomRouteReq.city_code)
}
inline ::std::string* NewUpdateRadomRouteReq::mutable_city_code() {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewUpdateRadomRouteReq.city_code)
  return city_code_;
}
inline ::std::string* NewUpdateRadomRouteReq::release_city_code() {
  clear_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_code_;
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewUpdateRadomRouteReq::set_allocated_city_code(::std::string* city_code) {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_code_;
  }
  if (city_code) {
    set_has_city_code();
    city_code_ = city_code;
  } else {
    clear_has_city_code();
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewUpdateRadomRouteReq.city_code)
}

// required .IM.Buddy.TransportToolType start_transport_tool = 4;
inline bool NewUpdateRadomRouteReq::has_start_transport_tool() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_start_transport_tool() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewUpdateRadomRouteReq::clear_has_start_transport_tool() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewUpdateRadomRouteReq::clear_start_transport_tool() {
  start_transport_tool_ = 1;
  clear_has_start_transport_tool();
}
inline ::IM::Buddy::TransportToolType NewUpdateRadomRouteReq::start_transport_tool() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.start_transport_tool)
  return static_cast< ::IM::Buddy::TransportToolType >(start_transport_tool_);
}
inline void NewUpdateRadomRouteReq::set_start_transport_tool(::IM::Buddy::TransportToolType value) {
  assert(::IM::Buddy::TransportToolType_IsValid(value));
  set_has_start_transport_tool();
  start_transport_tool_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.start_transport_tool)
}

// required .IM.Buddy.TransportToolType end_transport_tool = 5;
inline bool NewUpdateRadomRouteReq::has_end_transport_tool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_end_transport_tool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewUpdateRadomRouteReq::clear_has_end_transport_tool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewUpdateRadomRouteReq::clear_end_transport_tool() {
  end_transport_tool_ = 1;
  clear_has_end_transport_tool();
}
inline ::IM::Buddy::TransportToolType NewUpdateRadomRouteReq::end_transport_tool() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.end_transport_tool)
  return static_cast< ::IM::Buddy::TransportToolType >(end_transport_tool_);
}
inline void NewUpdateRadomRouteReq::set_end_transport_tool(::IM::Buddy::TransportToolType value) {
  assert(::IM::Buddy::TransportToolType_IsValid(value));
  set_has_end_transport_tool();
  end_transport_tool_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.end_transport_tool)
}

// required string start_time = 6;
inline bool NewUpdateRadomRouteReq::has_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_start_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewUpdateRadomRouteReq::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewUpdateRadomRouteReq::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& NewUpdateRadomRouteReq::start_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.start_time)
  return *start_time_;
}
inline void NewUpdateRadomRouteReq::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.start_time)
}
inline void NewUpdateRadomRouteReq::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewUpdateRadomRouteReq.start_time)
}
inline void NewUpdateRadomRouteReq::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewUpdateRadomRouteReq.start_time)
}
inline ::std::string* NewUpdateRadomRouteReq::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewUpdateRadomRouteReq.start_time)
  return start_time_;
}
inline ::std::string* NewUpdateRadomRouteReq::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewUpdateRadomRouteReq::set_allocated_start_time(::std::string* start_time) {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_time_;
  }
  if (start_time) {
    set_has_start_time();
    start_time_ = start_time;
  } else {
    clear_has_start_time();
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewUpdateRadomRouteReq.start_time)
}

// required string end_time = 7;
inline bool NewUpdateRadomRouteReq::has_end_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_end_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewUpdateRadomRouteReq::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewUpdateRadomRouteReq::clear_end_time() {
  if (end_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_->clear();
  }
  clear_has_end_time();
}
inline const ::std::string& NewUpdateRadomRouteReq::end_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.end_time)
  return *end_time_;
}
inline void NewUpdateRadomRouteReq::set_end_time(const ::std::string& value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.end_time)
}
inline void NewUpdateRadomRouteReq::set_end_time(const char* value) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewUpdateRadomRouteReq.end_time)
}
inline void NewUpdateRadomRouteReq::set_end_time(const char* value, size_t size) {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  end_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewUpdateRadomRouteReq.end_time)
}
inline ::std::string* NewUpdateRadomRouteReq::mutable_end_time() {
  set_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewUpdateRadomRouteReq.end_time)
  return end_time_;
}
inline ::std::string* NewUpdateRadomRouteReq::release_end_time() {
  clear_has_end_time();
  if (end_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_time_;
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewUpdateRadomRouteReq::set_allocated_end_time(::std::string* end_time) {
  if (end_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_time_;
  }
  if (end_time) {
    set_has_end_time();
    end_time_ = end_time;
  } else {
    clear_has_end_time();
    end_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewUpdateRadomRouteReq.end_time)
}

// repeated uint32 scenic_ids = 8;
inline int NewUpdateRadomRouteReq::scenic_ids_size() const {
  return scenic_ids_.size();
}
inline void NewUpdateRadomRouteReq::clear_scenic_ids() {
  scenic_ids_.Clear();
}
inline ::google::protobuf::uint32 NewUpdateRadomRouteReq::scenic_ids(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.scenic_ids)
  return scenic_ids_.Get(index);
}
inline void NewUpdateRadomRouteReq::set_scenic_ids(int index, ::google::protobuf::uint32 value) {
  scenic_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.scenic_ids)
}
inline void NewUpdateRadomRouteReq::add_scenic_ids(::google::protobuf::uint32 value) {
  scenic_ids_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.NewUpdateRadomRouteReq.scenic_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NewUpdateRadomRouteReq::scenic_ids() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.NewUpdateRadomRouteReq.scenic_ids)
  return scenic_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NewUpdateRadomRouteReq::mutable_scenic_ids() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.NewUpdateRadomRouteReq.scenic_ids)
  return &scenic_ids_;
}

// required string tag = 9;
inline bool NewUpdateRadomRouteReq::has_tag() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_tag() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewUpdateRadomRouteReq::clear_has_tag() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewUpdateRadomRouteReq::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& NewUpdateRadomRouteReq::tag() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.tag)
  return *tag_;
}
inline void NewUpdateRadomRouteReq::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.tag)
}
inline void NewUpdateRadomRouteReq::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewUpdateRadomRouteReq.tag)
}
inline void NewUpdateRadomRouteReq::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewUpdateRadomRouteReq.tag)
}
inline ::std::string* NewUpdateRadomRouteReq::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewUpdateRadomRouteReq.tag)
  return tag_;
}
inline ::std::string* NewUpdateRadomRouteReq::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewUpdateRadomRouteReq::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewUpdateRadomRouteReq.tag)
}

// optional bytes attach_data = 20;
inline bool NewUpdateRadomRouteReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewUpdateRadomRouteReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewUpdateRadomRouteReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewUpdateRadomRouteReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewUpdateRadomRouteReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteReq.attach_data)
  return *attach_data_;
}
inline void NewUpdateRadomRouteReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteReq.attach_data)
}
inline void NewUpdateRadomRouteReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewUpdateRadomRouteReq.attach_data)
}
inline void NewUpdateRadomRouteReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewUpdateRadomRouteReq.attach_data)
}
inline ::std::string* NewUpdateRadomRouteReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewUpdateRadomRouteReq.attach_data)
  return attach_data_;
}
inline ::std::string* NewUpdateRadomRouteReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewUpdateRadomRouteReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewUpdateRadomRouteReq.attach_data)
}

// -------------------------------------------------------------------

// NewUpdateRadomRouteRsp

// required uint32 user_id = 1;
inline bool NewUpdateRadomRouteRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewUpdateRadomRouteRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewUpdateRadomRouteRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewUpdateRadomRouteRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewUpdateRadomRouteRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteRsp.user_id)
  return user_id_;
}
inline void NewUpdateRadomRouteRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteRsp.user_id)
}

// required uint32 result_code = 2;
inline bool NewUpdateRadomRouteRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewUpdateRadomRouteRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewUpdateRadomRouteRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewUpdateRadomRouteRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 NewUpdateRadomRouteRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteRsp.result_code)
  return result_code_;
}
inline void NewUpdateRadomRouteRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteRsp.result_code)
}

// required .IM.Buddy.Route route = 3;
inline bool NewUpdateRadomRouteRsp::has_route() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewUpdateRadomRouteRsp::set_has_route() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewUpdateRadomRouteRsp::clear_has_route() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewUpdateRadomRouteRsp::clear_route() {
  if (route_ != NULL) route_->::IM::Buddy::Route::Clear();
  clear_has_route();
}
inline const ::IM::Buddy::Route& NewUpdateRadomRouteRsp::route() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteRsp.route)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return route_ != NULL ? *route_ : *default_instance().route_;
#else
  return route_ != NULL ? *route_ : *default_instance_->route_;
#endif
}
inline ::IM::Buddy::Route* NewUpdateRadomRouteRsp::mutable_route() {
  set_has_route();
  if (route_ == NULL) route_ = new ::IM::Buddy::Route;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewUpdateRadomRouteRsp.route)
  return route_;
}
inline ::IM::Buddy::Route* NewUpdateRadomRouteRsp::release_route() {
  clear_has_route();
  ::IM::Buddy::Route* temp = route_;
  route_ = NULL;
  return temp;
}
inline void NewUpdateRadomRouteRsp::set_allocated_route(::IM::Buddy::Route* route) {
  delete route_;
  route_ = route;
  if (route) {
    set_has_route();
  } else {
    clear_has_route();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewUpdateRadomRouteRsp.route)
}

// optional bytes attach_data = 20;
inline bool NewUpdateRadomRouteRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewUpdateRadomRouteRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewUpdateRadomRouteRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewUpdateRadomRouteRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewUpdateRadomRouteRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewUpdateRadomRouteRsp.attach_data)
  return *attach_data_;
}
inline void NewUpdateRadomRouteRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewUpdateRadomRouteRsp.attach_data)
}
inline void NewUpdateRadomRouteRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewUpdateRadomRouteRsp.attach_data)
}
inline void NewUpdateRadomRouteRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewUpdateRadomRouteRsp.attach_data)
}
inline ::std::string* NewUpdateRadomRouteRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewUpdateRadomRouteRsp.attach_data)
  return attach_data_;
}
inline ::std::string* NewUpdateRadomRouteRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewUpdateRadomRouteRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewUpdateRadomRouteRsp.attach_data)
}

// -------------------------------------------------------------------

// NewCreateMyTravelReq

// required uint32 user_id = 1;
inline bool NewCreateMyTravelReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewCreateMyTravelReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewCreateMyTravelReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewCreateMyTravelReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewCreateMyTravelReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelReq.user_id)
  return user_id_;
}
inline void NewCreateMyTravelReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelReq.user_id)
}

// required uint32 day_count = 2;
inline bool NewCreateMyTravelReq::has_day_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewCreateMyTravelReq::set_has_day_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewCreateMyTravelReq::clear_has_day_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewCreateMyTravelReq::clear_day_count() {
  day_count_ = 0u;
  clear_has_day_count();
}
inline ::google::protobuf::uint32 NewCreateMyTravelReq::day_count() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelReq.day_count)
  return day_count_;
}
inline void NewCreateMyTravelReq::set_day_count(::google::protobuf::uint32 value) {
  set_has_day_count();
  day_count_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelReq.day_count)
}

// required string city_code = 3;
inline bool NewCreateMyTravelReq::has_city_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewCreateMyTravelReq::set_has_city_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewCreateMyTravelReq::clear_has_city_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewCreateMyTravelReq::clear_city_code() {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_->clear();
  }
  clear_has_city_code();
}
inline const ::std::string& NewCreateMyTravelReq::city_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelReq.city_code)
  return *city_code_;
}
inline void NewCreateMyTravelReq::set_city_code(const ::std::string& value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelReq.city_code)
}
inline void NewCreateMyTravelReq::set_city_code(const char* value) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewCreateMyTravelReq.city_code)
}
inline void NewCreateMyTravelReq::set_city_code(const char* value, size_t size) {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  city_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewCreateMyTravelReq.city_code)
}
inline ::std::string* NewCreateMyTravelReq::mutable_city_code() {
  set_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateMyTravelReq.city_code)
  return city_code_;
}
inline ::std::string* NewCreateMyTravelReq::release_city_code() {
  clear_has_city_code();
  if (city_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_code_;
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewCreateMyTravelReq::set_allocated_city_code(::std::string* city_code) {
  if (city_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_code_;
  }
  if (city_code) {
    set_has_city_code();
    city_code_ = city_code;
  } else {
    clear_has_city_code();
    city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewCreateMyTravelReq.city_code)
}

// repeated string tags = 4;
inline int NewCreateMyTravelReq::tags_size() const {
  return tags_.size();
}
inline void NewCreateMyTravelReq::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& NewCreateMyTravelReq::tags(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelReq.tags)
  return tags_.Get(index);
}
inline ::std::string* NewCreateMyTravelReq::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateMyTravelReq.tags)
  return tags_.Mutable(index);
}
inline void NewCreateMyTravelReq::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelReq.tags)
  tags_.Mutable(index)->assign(value);
}
inline void NewCreateMyTravelReq::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewCreateMyTravelReq.tags)
}
inline void NewCreateMyTravelReq::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewCreateMyTravelReq.tags)
}
inline ::std::string* NewCreateMyTravelReq::add_tags() {
  return tags_.Add();
}
inline void NewCreateMyTravelReq::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.NewCreateMyTravelReq.tags)
}
inline void NewCreateMyTravelReq::add_tags(const char* value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IM.Buddy.NewCreateMyTravelReq.tags)
}
inline void NewCreateMyTravelReq::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IM.Buddy.NewCreateMyTravelReq.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NewCreateMyTravelReq::tags() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.NewCreateMyTravelReq.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NewCreateMyTravelReq::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.NewCreateMyTravelReq.tags)
  return &tags_;
}

// optional bytes attach_data = 20;
inline bool NewCreateMyTravelReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewCreateMyTravelReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewCreateMyTravelReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewCreateMyTravelReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewCreateMyTravelReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelReq.attach_data)
  return *attach_data_;
}
inline void NewCreateMyTravelReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelReq.attach_data)
}
inline void NewCreateMyTravelReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewCreateMyTravelReq.attach_data)
}
inline void NewCreateMyTravelReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewCreateMyTravelReq.attach_data)
}
inline ::std::string* NewCreateMyTravelReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateMyTravelReq.attach_data)
  return attach_data_;
}
inline ::std::string* NewCreateMyTravelReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewCreateMyTravelReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewCreateMyTravelReq.attach_data)
}

// -------------------------------------------------------------------

// NewCreateMyTravelRsp

// required uint32 user_id = 1;
inline bool NewCreateMyTravelRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewCreateMyTravelRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewCreateMyTravelRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewCreateMyTravelRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewCreateMyTravelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelRsp.user_id)
  return user_id_;
}
inline void NewCreateMyTravelRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelRsp.user_id)
}

// required uint32 result_code = 2;
inline bool NewCreateMyTravelRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewCreateMyTravelRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewCreateMyTravelRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewCreateMyTravelRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 NewCreateMyTravelRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelRsp.result_code)
  return result_code_;
}
inline void NewCreateMyTravelRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelRsp.result_code)
}

// required .IM.Buddy.Route route = 3;
inline bool NewCreateMyTravelRsp::has_route() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewCreateMyTravelRsp::set_has_route() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewCreateMyTravelRsp::clear_has_route() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewCreateMyTravelRsp::clear_route() {
  if (route_ != NULL) route_->::IM::Buddy::Route::Clear();
  clear_has_route();
}
inline const ::IM::Buddy::Route& NewCreateMyTravelRsp::route() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelRsp.route)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return route_ != NULL ? *route_ : *default_instance().route_;
#else
  return route_ != NULL ? *route_ : *default_instance_->route_;
#endif
}
inline ::IM::Buddy::Route* NewCreateMyTravelRsp::mutable_route() {
  set_has_route();
  if (route_ == NULL) route_ = new ::IM::Buddy::Route;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateMyTravelRsp.route)
  return route_;
}
inline ::IM::Buddy::Route* NewCreateMyTravelRsp::release_route() {
  clear_has_route();
  ::IM::Buddy::Route* temp = route_;
  route_ = NULL;
  return temp;
}
inline void NewCreateMyTravelRsp::set_allocated_route(::IM::Buddy::Route* route) {
  delete route_;
  route_ = route;
  if (route) {
    set_has_route();
  } else {
    clear_has_route();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewCreateMyTravelRsp.route)
}

// optional bytes attach_data = 20;
inline bool NewCreateMyTravelRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewCreateMyTravelRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewCreateMyTravelRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewCreateMyTravelRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewCreateMyTravelRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateMyTravelRsp.attach_data)
  return *attach_data_;
}
inline void NewCreateMyTravelRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateMyTravelRsp.attach_data)
}
inline void NewCreateMyTravelRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewCreateMyTravelRsp.attach_data)
}
inline void NewCreateMyTravelRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewCreateMyTravelRsp.attach_data)
}
inline ::std::string* NewCreateMyTravelRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateMyTravelRsp.attach_data)
  return attach_data_;
}
inline ::std::string* NewCreateMyTravelRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewCreateMyTravelRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewCreateMyTravelRsp.attach_data)
}

// -------------------------------------------------------------------

// NewCreateCollectRouteReq

// required uint32 user_id = 1;
inline bool NewCreateCollectRouteReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewCreateCollectRouteReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewCreateCollectRouteReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewCreateCollectRouteReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewCreateCollectRouteReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateCollectRouteReq.user_id)
  return user_id_;
}
inline void NewCreateCollectRouteReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateCollectRouteReq.user_id)
}

// required .IM.Buddy.CollectionRoute collect = 2;
inline bool NewCreateCollectRouteReq::has_collect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewCreateCollectRouteReq::set_has_collect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewCreateCollectRouteReq::clear_has_collect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewCreateCollectRouteReq::clear_collect() {
  if (collect_ != NULL) collect_->::IM::Buddy::CollectionRoute::Clear();
  clear_has_collect();
}
inline const ::IM::Buddy::CollectionRoute& NewCreateCollectRouteReq::collect() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateCollectRouteReq.collect)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return collect_ != NULL ? *collect_ : *default_instance().collect_;
#else
  return collect_ != NULL ? *collect_ : *default_instance_->collect_;
#endif
}
inline ::IM::Buddy::CollectionRoute* NewCreateCollectRouteReq::mutable_collect() {
  set_has_collect();
  if (collect_ == NULL) collect_ = new ::IM::Buddy::CollectionRoute;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateCollectRouteReq.collect)
  return collect_;
}
inline ::IM::Buddy::CollectionRoute* NewCreateCollectRouteReq::release_collect() {
  clear_has_collect();
  ::IM::Buddy::CollectionRoute* temp = collect_;
  collect_ = NULL;
  return temp;
}
inline void NewCreateCollectRouteReq::set_allocated_collect(::IM::Buddy::CollectionRoute* collect) {
  delete collect_;
  collect_ = collect;
  if (collect) {
    set_has_collect();
  } else {
    clear_has_collect();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewCreateCollectRouteReq.collect)
}

// optional bytes attach_data = 20;
inline bool NewCreateCollectRouteReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewCreateCollectRouteReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewCreateCollectRouteReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewCreateCollectRouteReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewCreateCollectRouteReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateCollectRouteReq.attach_data)
  return *attach_data_;
}
inline void NewCreateCollectRouteReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateCollectRouteReq.attach_data)
}
inline void NewCreateCollectRouteReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewCreateCollectRouteReq.attach_data)
}
inline void NewCreateCollectRouteReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewCreateCollectRouteReq.attach_data)
}
inline ::std::string* NewCreateCollectRouteReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateCollectRouteReq.attach_data)
  return attach_data_;
}
inline ::std::string* NewCreateCollectRouteReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewCreateCollectRouteReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewCreateCollectRouteReq.attach_data)
}

// -------------------------------------------------------------------

// NewCreateCollectRouteRsp

// required uint32 user_id = 1;
inline bool NewCreateCollectRouteRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewCreateCollectRouteRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewCreateCollectRouteRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewCreateCollectRouteRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewCreateCollectRouteRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateCollectRouteRsp.user_id)
  return user_id_;
}
inline void NewCreateCollectRouteRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateCollectRouteRsp.user_id)
}

// required uint32 result_code = 2;
inline bool NewCreateCollectRouteRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewCreateCollectRouteRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewCreateCollectRouteRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewCreateCollectRouteRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 NewCreateCollectRouteRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateCollectRouteRsp.result_code)
  return result_code_;
}
inline void NewCreateCollectRouteRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateCollectRouteRsp.result_code)
}

// required uint32 collect_id = 3;
inline bool NewCreateCollectRouteRsp::has_collect_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewCreateCollectRouteRsp::set_has_collect_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewCreateCollectRouteRsp::clear_has_collect_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewCreateCollectRouteRsp::clear_collect_id() {
  collect_id_ = 0u;
  clear_has_collect_id();
}
inline ::google::protobuf::uint32 NewCreateCollectRouteRsp::collect_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateCollectRouteRsp.collect_id)
  return collect_id_;
}
inline void NewCreateCollectRouteRsp::set_collect_id(::google::protobuf::uint32 value) {
  set_has_collect_id();
  collect_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateCollectRouteRsp.collect_id)
}

// optional bytes attach_data = 20;
inline bool NewCreateCollectRouteRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewCreateCollectRouteRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewCreateCollectRouteRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewCreateCollectRouteRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewCreateCollectRouteRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewCreateCollectRouteRsp.attach_data)
  return *attach_data_;
}
inline void NewCreateCollectRouteRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewCreateCollectRouteRsp.attach_data)
}
inline void NewCreateCollectRouteRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewCreateCollectRouteRsp.attach_data)
}
inline void NewCreateCollectRouteRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewCreateCollectRouteRsp.attach_data)
}
inline ::std::string* NewCreateCollectRouteRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewCreateCollectRouteRsp.attach_data)
  return attach_data_;
}
inline ::std::string* NewCreateCollectRouteRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewCreateCollectRouteRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewCreateCollectRouteRsp.attach_data)
}

// -------------------------------------------------------------------

// NewDelCollectRouteReq

// required uint32 user_id = 1;
inline bool NewDelCollectRouteReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewDelCollectRouteReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewDelCollectRouteReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewDelCollectRouteReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewDelCollectRouteReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewDelCollectRouteReq.user_id)
  return user_id_;
}
inline void NewDelCollectRouteReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewDelCollectRouteReq.user_id)
}

// repeated uint32 collect_id = 2;
inline int NewDelCollectRouteReq::collect_id_size() const {
  return collect_id_.size();
}
inline void NewDelCollectRouteReq::clear_collect_id() {
  collect_id_.Clear();
}
inline ::google::protobuf::uint32 NewDelCollectRouteReq::collect_id(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewDelCollectRouteReq.collect_id)
  return collect_id_.Get(index);
}
inline void NewDelCollectRouteReq::set_collect_id(int index, ::google::protobuf::uint32 value) {
  collect_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewDelCollectRouteReq.collect_id)
}
inline void NewDelCollectRouteReq::add_collect_id(::google::protobuf::uint32 value) {
  collect_id_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.NewDelCollectRouteReq.collect_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NewDelCollectRouteReq::collect_id() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.NewDelCollectRouteReq.collect_id)
  return collect_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NewDelCollectRouteReq::mutable_collect_id() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.NewDelCollectRouteReq.collect_id)
  return &collect_id_;
}

// optional bytes attach_data = 20;
inline bool NewDelCollectRouteReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewDelCollectRouteReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewDelCollectRouteReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewDelCollectRouteReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewDelCollectRouteReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewDelCollectRouteReq.attach_data)
  return *attach_data_;
}
inline void NewDelCollectRouteReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewDelCollectRouteReq.attach_data)
}
inline void NewDelCollectRouteReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewDelCollectRouteReq.attach_data)
}
inline void NewDelCollectRouteReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewDelCollectRouteReq.attach_data)
}
inline ::std::string* NewDelCollectRouteReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewDelCollectRouteReq.attach_data)
  return attach_data_;
}
inline ::std::string* NewDelCollectRouteReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewDelCollectRouteReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewDelCollectRouteReq.attach_data)
}

// -------------------------------------------------------------------

// NewDelCollectRouteRsp

// required uint32 user_id = 1;
inline bool NewDelCollectRouteRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewDelCollectRouteRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewDelCollectRouteRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewDelCollectRouteRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewDelCollectRouteRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewDelCollectRouteRsp.user_id)
  return user_id_;
}
inline void NewDelCollectRouteRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewDelCollectRouteRsp.user_id)
}

// required uint32 result_code = 2;
inline bool NewDelCollectRouteRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewDelCollectRouteRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewDelCollectRouteRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewDelCollectRouteRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 NewDelCollectRouteRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewDelCollectRouteRsp.result_code)
  return result_code_;
}
inline void NewDelCollectRouteRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewDelCollectRouteRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool NewDelCollectRouteRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewDelCollectRouteRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewDelCollectRouteRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewDelCollectRouteRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewDelCollectRouteRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewDelCollectRouteRsp.attach_data)
  return *attach_data_;
}
inline void NewDelCollectRouteRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewDelCollectRouteRsp.attach_data)
}
inline void NewDelCollectRouteRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewDelCollectRouteRsp.attach_data)
}
inline void NewDelCollectRouteRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewDelCollectRouteRsp.attach_data)
}
inline ::std::string* NewDelCollectRouteRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewDelCollectRouteRsp.attach_data)
  return attach_data_;
}
inline ::std::string* NewDelCollectRouteRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewDelCollectRouteRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewDelCollectRouteRsp.attach_data)
}

// -------------------------------------------------------------------

// NewQueryCollectRouteReq

// required uint32 user_id = 1;
inline bool NewQueryCollectRouteReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewQueryCollectRouteReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewQueryCollectRouteReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewQueryCollectRouteReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewQueryCollectRouteReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryCollectRouteReq.user_id)
  return user_id_;
}
inline void NewQueryCollectRouteReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryCollectRouteReq.user_id)
}

// optional bytes attach_data = 20;
inline bool NewQueryCollectRouteReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewQueryCollectRouteReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewQueryCollectRouteReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewQueryCollectRouteReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewQueryCollectRouteReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryCollectRouteReq.attach_data)
  return *attach_data_;
}
inline void NewQueryCollectRouteReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryCollectRouteReq.attach_data)
}
inline void NewQueryCollectRouteReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewQueryCollectRouteReq.attach_data)
}
inline void NewQueryCollectRouteReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewQueryCollectRouteReq.attach_data)
}
inline ::std::string* NewQueryCollectRouteReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryCollectRouteReq.attach_data)
  return attach_data_;
}
inline ::std::string* NewQueryCollectRouteReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewQueryCollectRouteReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewQueryCollectRouteReq.attach_data)
}

// -------------------------------------------------------------------

// NewQueryCollectRouteRsp

// required uint32 user_id = 1;
inline bool NewQueryCollectRouteRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewQueryCollectRouteRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewQueryCollectRouteRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewQueryCollectRouteRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 NewQueryCollectRouteRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryCollectRouteRsp.user_id)
  return user_id_;
}
inline void NewQueryCollectRouteRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryCollectRouteRsp.user_id)
}

// required uint32 result_code = 2;
inline bool NewQueryCollectRouteRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewQueryCollectRouteRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewQueryCollectRouteRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewQueryCollectRouteRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 NewQueryCollectRouteRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryCollectRouteRsp.result_code)
  return result_code_;
}
inline void NewQueryCollectRouteRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryCollectRouteRsp.result_code)
}

// repeated .IM.Buddy.CollectionRoute collections = 3;
inline int NewQueryCollectRouteRsp::collections_size() const {
  return collections_.size();
}
inline void NewQueryCollectRouteRsp::clear_collections() {
  collections_.Clear();
}
inline const ::IM::Buddy::CollectionRoute& NewQueryCollectRouteRsp::collections(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryCollectRouteRsp.collections)
  return collections_.Get(index);
}
inline ::IM::Buddy::CollectionRoute* NewQueryCollectRouteRsp::mutable_collections(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryCollectRouteRsp.collections)
  return collections_.Mutable(index);
}
inline ::IM::Buddy::CollectionRoute* NewQueryCollectRouteRsp::add_collections() {
  // @@protoc_insertion_point(field_add:IM.Buddy.NewQueryCollectRouteRsp.collections)
  return collections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::CollectionRoute >&
NewQueryCollectRouteRsp::collections() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.NewQueryCollectRouteRsp.collections)
  return collections_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::CollectionRoute >*
NewQueryCollectRouteRsp::mutable_collections() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.NewQueryCollectRouteRsp.collections)
  return &collections_;
}

// optional bytes attach_data = 20;
inline bool NewQueryCollectRouteRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewQueryCollectRouteRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewQueryCollectRouteRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewQueryCollectRouteRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& NewQueryCollectRouteRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.NewQueryCollectRouteRsp.attach_data)
  return *attach_data_;
}
inline void NewQueryCollectRouteRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.NewQueryCollectRouteRsp.attach_data)
}
inline void NewQueryCollectRouteRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.NewQueryCollectRouteRsp.attach_data)
}
inline void NewQueryCollectRouteRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.NewQueryCollectRouteRsp.attach_data)
}
inline ::std::string* NewQueryCollectRouteRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.NewQueryCollectRouteRsp.attach_data)
  return attach_data_;
}
inline ::std::string* NewQueryCollectRouteRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewQueryCollectRouteRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.NewQueryCollectRouteRsp.attach_data)
}

// -------------------------------------------------------------------

// Info_Modify_Req

// required uint32 user_id = 1;
inline bool Info_Modify_Req::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Info_Modify_Req::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Info_Modify_Req::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Info_Modify_Req::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 Info_Modify_Req::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Info_Modify_Req.user_id)
  return user_id_;
}
inline void Info_Modify_Req::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Info_Modify_Req.user_id)
}

// required .IM.Buddy.ModifyType modify_type = 2;
inline bool Info_Modify_Req::has_modify_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Info_Modify_Req::set_has_modify_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Info_Modify_Req::clear_has_modify_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Info_Modify_Req::clear_modify_type() {
  modify_type_ = 1;
  clear_has_modify_type();
}
inline ::IM::Buddy::ModifyType Info_Modify_Req::modify_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Info_Modify_Req.modify_type)
  return static_cast< ::IM::Buddy::ModifyType >(modify_type_);
}
inline void Info_Modify_Req::set_modify_type(::IM::Buddy::ModifyType value) {
  assert(::IM::Buddy::ModifyType_IsValid(value));
  set_has_modify_type();
  modify_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Info_Modify_Req.modify_type)
}

// required string modify_context = 3;
inline bool Info_Modify_Req::has_modify_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Info_Modify_Req::set_has_modify_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Info_Modify_Req::clear_has_modify_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Info_Modify_Req::clear_modify_context() {
  if (modify_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modify_context_->clear();
  }
  clear_has_modify_context();
}
inline const ::std::string& Info_Modify_Req::modify_context() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Info_Modify_Req.modify_context)
  return *modify_context_;
}
inline void Info_Modify_Req::set_modify_context(const ::std::string& value) {
  set_has_modify_context();
  if (modify_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modify_context_ = new ::std::string;
  }
  modify_context_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.Info_Modify_Req.modify_context)
}
inline void Info_Modify_Req::set_modify_context(const char* value) {
  set_has_modify_context();
  if (modify_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modify_context_ = new ::std::string;
  }
  modify_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.Info_Modify_Req.modify_context)
}
inline void Info_Modify_Req::set_modify_context(const char* value, size_t size) {
  set_has_modify_context();
  if (modify_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modify_context_ = new ::std::string;
  }
  modify_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.Info_Modify_Req.modify_context)
}
inline ::std::string* Info_Modify_Req::mutable_modify_context() {
  set_has_modify_context();
  if (modify_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modify_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Info_Modify_Req.modify_context)
  return modify_context_;
}
inline ::std::string* Info_Modify_Req::release_modify_context() {
  clear_has_modify_context();
  if (modify_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modify_context_;
    modify_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Info_Modify_Req::set_allocated_modify_context(::std::string* modify_context) {
  if (modify_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modify_context_;
  }
  if (modify_context) {
    set_has_modify_context();
    modify_context_ = modify_context;
  } else {
    clear_has_modify_context();
    modify_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.Info_Modify_Req.modify_context)
}

// optional bytes attach_data = 20;
inline bool Info_Modify_Req::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Info_Modify_Req::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Info_Modify_Req::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Info_Modify_Req::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& Info_Modify_Req::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Info_Modify_Req.attach_data)
  return *attach_data_;
}
inline void Info_Modify_Req::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.Info_Modify_Req.attach_data)
}
inline void Info_Modify_Req::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.Info_Modify_Req.attach_data)
}
inline void Info_Modify_Req::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.Info_Modify_Req.attach_data)
}
inline ::std::string* Info_Modify_Req::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Info_Modify_Req.attach_data)
  return attach_data_;
}
inline ::std::string* Info_Modify_Req::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Info_Modify_Req::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.Info_Modify_Req.attach_data)
}

// -------------------------------------------------------------------

// Info_Modify_Rsp

// required uint32 user_id = 1;
inline bool Info_Modify_Rsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Info_Modify_Rsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Info_Modify_Rsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Info_Modify_Rsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 Info_Modify_Rsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Info_Modify_Rsp.user_id)
  return user_id_;
}
inline void Info_Modify_Rsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Info_Modify_Rsp.user_id)
}

// required .IM.BaseDefine.ResultType ret_code = 2;
inline bool Info_Modify_Rsp::has_ret_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Info_Modify_Rsp::set_has_ret_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Info_Modify_Rsp::clear_has_ret_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Info_Modify_Rsp::clear_ret_code() {
  ret_code_ = 0;
  clear_has_ret_code();
}
inline ::IM::BaseDefine::ResultType Info_Modify_Rsp::ret_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Info_Modify_Rsp.ret_code)
  return static_cast< ::IM::BaseDefine::ResultType >(ret_code_);
}
inline void Info_Modify_Rsp::set_ret_code(::IM::BaseDefine::ResultType value) {
  assert(::IM::BaseDefine::ResultType_IsValid(value));
  set_has_ret_code();
  ret_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.Info_Modify_Rsp.ret_code)
}

// optional bytes attach_data = 20;
inline bool Info_Modify_Rsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Info_Modify_Rsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Info_Modify_Rsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Info_Modify_Rsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& Info_Modify_Rsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.Info_Modify_Rsp.attach_data)
  return *attach_data_;
}
inline void Info_Modify_Rsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.Info_Modify_Rsp.attach_data)
}
inline void Info_Modify_Rsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.Info_Modify_Rsp.attach_data)
}
inline void Info_Modify_Rsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.Info_Modify_Rsp.attach_data)
}
inline ::std::string* Info_Modify_Rsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.Info_Modify_Rsp.attach_data)
  return attach_data_;
}
inline ::std::string* Info_Modify_Rsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Info_Modify_Rsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.Info_Modify_Rsp.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Buddy
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
